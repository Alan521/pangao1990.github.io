<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[上传代码到github报Connection timed out错误]]></title>
    <url>%2F%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E6%8A%A5Connection_timed_out%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[报错好端端的，不知道为啥无法提交代码到 github ，报错信息如下：解决办法在网上找了一圈解决办法，最终可行的办法如下：1、进入存放公钥私钥( id_rsa 和 id_rsa.pub )的文件夹里，因为我是Mac，方法如下，若是win系统，请自行谷歌：1cd ~/.ssh2、新建 config 文本：1vi config3、写入以下内容，其中User为登录github的账号名称：123456Host github.comUser pangao1990@qq.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 4434、执行 ssh -T git@github.com 时，会出现提示如下，回车”yes”即可：后记尝试了比较多的办法，就这一种成功了。但不代表你的问题也可以用这种办法解决，我只是提供一种网上的思路。如果帮不到你，不看我的博客就是了，千万不要喷我，最近被喷怕了。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件路径获取文件名]]></title>
    <url>%2FPHP%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021$file = &apos;/blog/pangao/vip/index.php&apos;;$path_parts = pathinfo($file);echo &apos;目录名称&apos; . $path_parts[&apos;dirname&apos;], &apos;&lt;br/&gt;&apos;; // /blog/pangao/vipecho &apos;文件全名&apos; . $path_parts[&apos;basename&apos;], &apos;&lt;br/&gt;&apos;; // index.phpecho &apos;文件后缀&apos; . $path_parts[&apos;extension&apos;], &apos;&lt;br/&gt;&apos;;// phpecho &apos;文件名称&apos; . $path_parts[&apos;filename&apos;], &apos;&lt;br/&gt;&apos;; // index // PHP &gt;= 5.2.0或者echo &apos;目录名称&apos; . pathinfo($file, PATHINFO_DIRNAME), &apos;&lt;br/&gt;&apos;; // /blog/pangao/vipecho &apos;文件全名&apos; . pathinfo($file, PATHINFO_BASENAME), &apos;&lt;br/&gt;&apos;; // index.phpecho &apos;文件后缀&apos; . pathinfo($file, PATHINFO_EXTENSION), &apos;&lt;br/&gt;&apos;;// phpecho &apos;文件名称&apos; . pathinfo($file, PATHINFO_FILENAME), &apos;&lt;br/&gt;&apos;; // index // PHP &gt;= 5.2.0]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python使用pip安装包、查看是否已安装、检测是否需要更新、升级包、卸载包]]></title>
    <url>%2FPython%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85%E5%8C%85%E3%80%81%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%89%E8%A3%85%E3%80%81%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0%E3%80%81%E5%8D%87%E7%BA%A7%E5%8C%85%E3%80%81%E5%8D%B8%E8%BD%BD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[pip安装包123$ pip install [安装包名] [...] Successfully installed SomePackage #安装成功pip查看是否已安装1234567$ pip show --files [安装包名] Name:SomePackage # 包名 Version:1.0 # 版本号 Location:/my/env/lib/pythonx.x/site-packages # 安装位置 Files: # 包含文件等等 ../somepackage/__init__.py [...]pip检查哪些包需要更新1$ pip list --outdatedpip升级包1$ pip install --upgrade [要升级的包名]pip卸载包1$ pip uninstall [要卸载的包名]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中使用os.system函数调用外部命令]]></title>
    <url>%2FPython%E4%B8%AD%E4%BD%BF%E7%94%A8os.system%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[system 函数可以将字符串转化成命令在服务器上运行；其原理是每一条 system 函数执行时，其会创建一个子进程在系统上执行命令行，子进程的执行结果无法影响主进程。执行多条语句，如下：12345import osos.system(&apos;cd /usr/local &amp;&amp; mkdir aaa.txt&apos;)# oros.system(&apos;cd /usr/local ; mkdir aaa.txt&apos;)os.system 默认阻塞当前程序执行，在 cmd 命令前加入 start 可不阻塞当前程序执行。如下：123import osos.system(&apos;start ping www.baidu.com -t&apos;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python命令行参数解析模块argparse]]></title>
    <url>%2FPython%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97argparse%2F</url>
    <content type="text"><![CDATA[前言以前 optparse 比较火，但是在python2.7版本后，官方不再维护这个模块，转而大力支持 argparse 。argparse 模块可以让人轻松编写用户友好的命令行接口。她可以从 sys.argv 中解析出参数，并自动生成帮助和使用手册，还能在传入无效参数时报出错误信息。基础用法由于是标准库，所以不需要安装，直接使用：12345import argparseparser = argparse.ArgumentParser()# parser.add_argument(&quot;-i&quot;, &quot;--info&quot;, action = &quot;store&quot;, type = &quot;string&quot;, dest = &quot;sample_info&quot;, help = &quot;the sample information&quot;)args = parser.parse_args()# print(args.sample_info)运行以上代码，如下：不输入参数，也没有输出结果：1$ python3 test.py输入默认参数 --help （也可缩写为 -h ），会输出自动生成的帮助信息：1234567$ python3 test.py --help# 输出：usage: test.py [-h]optional arguments: -h, --help show this help message and exit输入错误参数，会输出报错信息：12345$ python3 test.py -verbose# 输出：usage: test.py [-h]test.py: error: unrecognized arguments: --verbose创建解析器使用 argparse 的第一步是创建一个 ArgumentParser 对象，如下：12345import argparseparser = argparse.ArgumentParser(prog=None, usage=None,description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars=&apos;-&apos;, fromfile_prefix_chars=None, argument_default=None, conflict_handler=&apos;error&apos;, add_help=True, allow_abbrev=True)创建一个新的 ArgumentParser 对象。所有的参数都应当作为关键字参数传入。部分参数在下面都有它更详细的描述，但简而言之，它们是：prog - 程序的名称（默认：sys.argv[0]）usage - 描述程序用途的字符串（默认值：从添加到解析器的参数生成）description - 在参数帮助文档之前显示的文本（默认值：无）epilog - 在参数帮助文档之后显示的文本（默认值：无）parents - 一个 ArgumentParser 对象的列表，它们的参数也应包含在内formatter_class - 用于自定义帮助文档输出格式的类prefix_chars - 可选参数的前缀字符集合（默认值：’-‘）fromfile_prefix_chars - 当需要从文件中读取其他参数时，用于标识文件名的前缀字符集合（默认值：None）argument_default - 参数的全局默认值（默认值： None）conflict_handler - 解决冲突选项的策略（通常是不必要的）add_help - 为解析器添加一个 -h/–help 选项（默认值： True）allow_abbrev - 如果缩写是无歧义的，则允许缩写长选项 （默认值：True）prog默认情况下， ArgumentParser 对象在帮助消息中显示的程序名称是 sys.argv[0] 。若要自定义程序名，则使用 prog ，如下：123456&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;myprogram&apos;)&gt;&gt;&gt; parser.print_help()usage: myprogram [-h]optional arguments: -h, --help show this help message and exit无论是从 sys.argv[0] 或是从 prog= 参数确定的程序名称，都可以在帮助消息里通过 %(prog)s 格式串来引用，如下：12345678&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;myprogram&apos;)&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, help=&apos;foo of the %(prog)s program&apos;)&gt;&gt;&gt; parser.print_help()usage: myprogram [-h] [--foo FOO]optional arguments: -h, --help show this help message and exit --foo FOO foo of the myprogram programusage构建用法消息，如下：123456789101112&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;PROG&apos;, usage=&apos;%(prog)s [options]&apos;)&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, nargs=&apos;?&apos;, help=&apos;foo help&apos;)&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;, nargs=&apos;+&apos;, help=&apos;bar help&apos;)&gt;&gt;&gt; parser.print_help()usage: PROG [options]positional arguments: bar bar helpoptional arguments: -h, --help show this help message and exit --foo [FOO] foo helpdescription简要描述这个程度做什么以及怎么做。在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间，如下：12345678&gt;&gt;&gt; parser = argparse.ArgumentParser(description=&apos;A foo that bars&apos;)&gt;&gt;&gt; parser.print_help()usage: argparse.py [-h]A foo that barsoptional arguments: -h, --help show this help message and exitepilog一些程序喜欢在 description 参数后显示额外的对程序的描述，如下：123456789101112&gt;&gt;&gt; parser = argparse.ArgumentParser(... description=&apos;A foo that bars&apos;,... epilog=&quot;And that&apos;s how you&apos;d foo a bar&quot;)&gt;&gt;&gt; parser.print_help()usage: argparse.py [-h]A foo that barsoptional arguments: -h, --help show this help message and exitAnd that&apos;s how you&apos;d foo a baradd_help是否关闭自动生成的帮助信息，如下：1234567&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;PROG&apos;, add_help=False)&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, help=&apos;foo help&apos;)&gt;&gt;&gt; parser.print_help()usage: PROG [--foo FOO]optional arguments: --foo FOO foo help添加参数使用 add_argument() 方法添加参数。其中，部分参数在下面都有它更详细的描述，但简而言之，它们是：name or flags - 一个命名或者一个选项字符串的列表，例如 foo 或 -f, –foo。action - 当参数在命令行中出现时使用的动作基本类型。nargs - 命令行参数应当消耗的数目。const - 被一些 action 和 nargs 选择所需求的常数。default - 当参数未在命令行中出现时使用的值。type - 命令行参数应当被转换成的类型。choices - 可用的参数的容器。required - 此命令行选项是否可省略 （仅选项可用）。help - 一个此选项作用的简单描述。metavar - 在使用方法消息中使用的参数值示例。dest - 被添加到 parse_args() 所返回对象上的属性名。name or flags第一个传递给 add_argument() 的参数必须是一系列 flags 或者是一个简单的参数名，如下：12345&gt;&gt;&gt; parser.add_argument(&apos;-f&apos;, &apos;--foo&apos;)or&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;)actionstore - 存储参数的值。这是默认的动作。如下:1234&gt;&gt;&gt; parser = argparse.ArgumentParser()&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;)&gt;&gt;&gt; parser.parse_args(&apos;--foo 1&apos;.split())Namespace(foo=&apos;1&apos;)store_const - 存储被 const 命名参数指定的值。 store_const 动作通常用在选项中来指定一些标志。如下：1234&gt;&gt;&gt; parser = argparse.ArgumentParser()&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, action=&apos;store_const&apos;, const=42)&gt;&gt;&gt; parser.parse_args([&apos;--foo&apos;])Namespace(foo=42)store_true 和 store_false - 这些是 store_const 分别用作存储 True 和 False 值的特殊用例。另外，它们的默认值分别为 False 和 True。如下：123456&gt;&gt;&gt; parser = argparse.ArgumentParser()&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, action=&apos;store_true&apos;)&gt;&gt;&gt; parser.add_argument(&apos;--bar&apos;, action=&apos;store_false&apos;)&gt;&gt;&gt; parser.add_argument(&apos;--baz&apos;, action=&apos;store_false&apos;)&gt;&gt;&gt; parser.parse_args(&apos;--foo --bar&apos;.split())Namespace(foo=True, bar=False, baz=True)append - 存储一个列表，并且将每个参数值追加到列表中。在允许多次使用选项时很有用。如下：1234&gt;&gt;&gt; parser = argparse.ArgumentParser()&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, action=&apos;append&apos;)&gt;&gt;&gt; parser.parse_args(&apos;--foo 1 --foo 2&apos;.split())Namespace(foo=[&apos;1&apos;, &apos;2&apos;])count - 计算一个关键字参数出现的数目或次数。例如，对于一个增长的详情等级来说有用。如下：1234&gt;&gt;&gt; parser = argparse.ArgumentParser()&gt;&gt;&gt; parser.add_argument(&apos;--verbose&apos;, &apos;-v&apos;, action=&apos;count&apos;)&gt;&gt;&gt; parser.parse_args([&apos;-vvv&apos;])Namespace(verbose=3)version - 期望有一个 version= 命名参数在 add_argument() 调用中，并打印版本信息并在调用后退出。如下：12345&gt;&gt;&gt; import argparse&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;PROG&apos;)&gt;&gt;&gt; parser.add_argument(&apos;--version&apos;, action=&apos;version&apos;, version=&apos;%(prog)s 2.0&apos;)&gt;&gt;&gt; parser.parse_args([&apos;--version&apos;])PROG 2.0]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中引入.svg图标]]></title>
    <url>%2Fvue%E4%B8%AD%E5%BC%95%E5%85%A5.svg%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[创建SvgIcon组件在 components 文件夹下新建 SvgIcon 文件夹，并在 SvgIcon 文件夹下新建 index.vue 文件，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;svg-icon&apos;, props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass() &#123; if (this.className) &#123; return &apos;svg-icon &apos; + this.className &#125; else &#123; return &apos;svg-icon&apos; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt;创建icons文件夹在 src 文件夹下新建 icons 文件夹，并在 icons 文件夹下新建 svg 文件夹和 index.js 文件。 svg 文件夹中用来存放各种扩展的.svg图标。 index.js 文件内容如下：12345678910import Vue from &apos;vue&apos;import SvgIcon from &apos;@/components/SvgIcon&apos;// svg组件// 注册到全局Vue.component(&apos;svg-icon&apos;, SvgIcon)const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)// eslint-disable-next-lineconst req = require.context(&apos;./svg&apos;, false, /\.svg$/)requireAll(req)在main.js中引入1import &apos;./icons&apos;下载插件在项目的目录下，执行命令：1npm i svg-sprite-loader --save配置在 build/webpack.base.conf.js 文件中，新增：123456789101112&#123; test: /\.svg$/, loader: &apos;svg-sprite-loader&apos;, include: [resolve(&apos;src/icons&apos;)], options: &#123; symbolId: &apos;icon-[name]&apos; &#125;&#125;和exclude: [resolve(&apos;src/icons&apos;)],添加后，如下代码所示：12345678910111213141516171819202122module: &#123; rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: &apos;url-loader&apos;, exclude: [resolve(&apos;src/icons&apos;)], options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\.svg$/, loader: &apos;svg-sprite-loader&apos;, include: [resolve(&apos;src/icons&apos;)], options: &#123; symbolId: &apos;icon-[name]&apos; &#125; &#125; ] &#125;,使用1&lt;svg-icon icon-class=&quot;user&quot; /&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python获取时间和日期]]></title>
    <url>%2FPython%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[获取以秒为单位的浮点时间 time() ，如下：12345import timeprint(time.time())# 1369031293.33获取人可以直观理解的时间 ctime() ，如下：12345import timeprint(time.ctime())# Mon May 20 14:29:30 2013获取格式化日期，如下：1234567import timest = time.strftime(&quot;%Y-%m-%d&quot;, time.localtime())print(st)# 2019-04-17具体的参数，如下：标识含义举例%Y完整的年2019%y年的后两位数，取值范围[00, 99]19%m十进制月份，取值范围[01, 12]04%B月份全写April%b月份简写Apr%d一个月的第几天，取值范围[01, 31]17%j一年中的第几天，取值范围[001, 366]107%w星期的十进制表示，取值范围 [0(星期天), 6]3%W这一年的星期数（星一为一个星期的第一天，开年的第一个星期一之前的天记到第0个星期）趋势范围[00, 53]15%U这一年的星期数（星期天为一个星期的第一天，开年的第一个星期天之前的天记到第0个星期）趋势范围[00, 53]15%A星期全称Wednesday%a星期简写Wed%H24小时制的小时，取值范围[00, 23]23%I12小时制的小时，取值范围 [01, 12]11%M分钟，取值范围 [00, 59]48%p上、下午，AM 或 PMPM%S秒，取值范围 [00, 59]30%Z时区名CST（China Standard Time）%c适合语言下的时间表示Wed Apr 17 23:42:49 2019%%%字符%]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python环境搭建及模块安装]]></title>
    <url>%2FPython%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Python 可应用于多个平台，如 Windows 、 Linux 和 MacOS 。首先可以在终端窗口输入 python 命令来查看在本地是否已经安装Python以及Python的安装版本。1. 环境搭建Windows 平台在 官网 下载安装包，如下：在 计算机 =&gt; 系统属性 查看系统类型，并以此下载对应Python版本，如下：双击安装包， 注意：一定要勾选下面的 Add Python 3.7 to PATH，若不选这一项，则后面需要手动配置环境变量，很麻烦。然后点击 Install Now ，如下：几秒钟后，就安装成功了，如下：在 cmd 终端中输入 python ，如下图则表示安装成功：输入 exit() ，即可退出python交互模式，如下：Linux 平台Linux下大部分系统默认自带python2.x的版本，最常见的是python2.6或python2.7版本，默认的python被系统很多程序所依赖，比如centos下的yum就是python2写的，所以默认版本不要轻易删除，否则会有一些问题，如果需要使用最新的Python3那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，python3和python2两个环境并存即可。我的Linux系统就自带2.6.6版本，如下：但这并不影响我另外安装新版Python，输入下载安装包命令，如下：1wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz创建安装目录，如下：1mkdir -p /usr/local/python3解压刚才下载好的 Python-3.7.3.tgz 包，如下：1tar -zxvf Python-3.7.3.tgz进入解压后的目录，编译安装，如下：123cd Python-3.7.3./configure --prefix=/usr/local/python3make &amp;&amp; make install如果期间报错，如下：则需要安装一个新包 libffi-devel ，命令如下：1yum install libffi-devel -y然后重新编译python，命令如下：12345cd Python-3.7.3./configure --prefix=/usr/local/python3make &amp;&amp; make install建立python3的软链，如下：1ln -s /usr/local/python3/bin/python3 /usr/bin/python3将/usr/local/python3/bin加入PATH，输入如下命令：1vim ~/.bash_profile则会打开 .bash_profile 文件，如下：输入 i ，进入编辑模式，修改 PATH ，如下：1PATH=$PATH:$HOME/bin:/usr/local/python3/bin按 esc 键退出编辑模式，按两个大写的 ZZ ，退出查看文件模式。执行下列命令，让上一步的修改生效，如下：1source ~/.bash_profile检查Python3和pip3是否正常可用，如下：可以看到，python3和pip3均已经安装成功。MacOS 平台苹果自带Python2.X，要安装新版本也很容易，直接在 官网 下载安装包，一件傻瓜式安装即可。2. 模块安装若要安装 openpyxl 模块，则在终端中输入命令，回车，如下：1pip3 install openpyxl即可。3. 更新源我们都知道，使用 python 开发时候会用到各种模块，而使用 pip 可以很方便的安装模块。可惜了，由于天朝独特的国情，访问不了官方的源，这时候，我们可以使用国内的 python 镜像源。如下：12清华：https://pypi.tuna.tsinghua.edu.cn/simple豆瓣：http://pypi.douban.com/simple/使用方法：1、临时使用只有安装 openpyxl 时使用指定源。如下：1pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple openpyxl2、一劳永逸Linux 和 Mac 系统：mkdir ~/.pip 建立一个文件夹。cd ~/.pip 进入我们创建的文件夹中。touch pip.conf 创建pip配置文件。vi pip.conf 编辑pip配置文件，写入代码如下：12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simpleZZ 保存退出。Windows 系统：直接在 user 目录中创建一个pip目录，如：C:\Users\xx\pip ，新建文件 pip.ini ，写入代码如下:12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python使用POP3和SMTP协议收发邮件]]></title>
    <url>%2FPython%E4%BD%BF%E7%94%A8POP3%E5%92%8CSMTP%E5%8D%8F%E8%AE%AE%E6%94%B6%E5%8F%91%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[先来了解一下收/发邮件有哪些协议：SMTP协议SMTP（Simple Mail Transfer Protocol），即简单邮件传输协议。相当于中转站，将邮件发送到客户端。POP3协议POP3（Post Office Protocol 3），即邮局协议的第3个版本，是电子邮件的第一个离线协议标准。该协议把邮件下载到本地计算机，不与服务器同步，缺点是更易丢失邮件或多次下载相同的邮件。IMAP协议IMAP（Internet Mail Access Protocol），即交互式邮件存取协议。该协议连接远程邮箱直接操作，与服务器内容同步。Exchange服务Exchange服务是一个设计完备的邮件服务器产品，提供了通常所需要的全部邮件服务功能。除了常规SMTP/POP协议服务之外，它还支持IMAP4 、LDAP和NNTP协议。Python内置对SMTP/POP3/IMAP的支持。更多详情请移步 Python官方教程SMTP发送邮件Python对SMTP支持有 smtplib 和 email 两个模块，email 负责构造邮件，smtplib 负责发送邮件。构造邮件构造最简单的纯文本邮件，如下：123from email.mime.text import MIMETextmsg = MIMEText(&apos;hello, send by Python...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)注意到构造 MIMEText 对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入 &#39;plain&#39; 表示纯文本，最终的MIME就是 &#39;text/plain&#39;，最后一定要用 utf-8 编码保证多语言兼容性。发送邮件12345678910111213141516import smtplib# 输入Email地址和口令:from_addr = &apos;test_from_addr@qq.com&apos;password = &apos;Password&apos;# 输入收件人地址:to_addr = &apos;test_to_addr@qq.com&apos;# 输入SMTP服务器地址:smtp_server = smtp.qq.comserver = smtplib.SMTP(smtp_server, 25) # SMTP协议默认端口是25# server.starttls() # 如果是SSL，则用 587 端口，再加上这句代码就行了server.set_debuglevel(1) # 打印出和SMTP服务器交互的所有信息server.login(from_addr, password) # 登录SMTP服务器server.sendmail(from_addr, [to_addr], msg.as_string()) # 发邮件server.quit()sendmail() 方法就是发邮件，由于可以一次发给多个人，所以传入一个 list，邮件正文是一个 str，as_string() 把MIMEText对象变成 str。注意： QQ邮件等需要手动开通 SMTP服务 ， 邮箱设置 =&gt; 账号 =&gt; POP3/SMTP服务，如下图：此时，我们就可以收到邮件了，如下：添加邮件标题、收/发件人邮件主题、显示发件人、收件人等信息并不是通过SMTP协议发送的，而是包含在 MIMEText 对象中，如下：1234567891011121314151617181920212223242526from email import encodersfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrimport smtplibdef _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr))from_addr = &apos;test_from_addr@qq.com&apos;password = &apos;Password&apos;to_addr = &apos;test_to_addr@qq.com&apos;smtp_server = smtp.qq.commsg = MIMEText(&apos;hello, send by Python...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)msg[&apos;From&apos;] = _format_addr(&apos;发件人昵称 &lt;%s&gt;&apos; % from_addr)msg[&apos;To&apos;] = _format_addr(&apos;收件人昵称 &lt;%s&gt;&apos; % to_addr)msg[&apos;Subject&apos;] = Header(&apos;这是个有主题的邮件&apos;, &apos;utf-8&apos;).encode()server = smtplib.SMTP(smtp_server, 25)server.set_debuglevel(1)server.login(from_addr, password)server.sendmail(from_addr, [to_addr], msg.as_string())server.quit()收到的邮件，如下：收件人并不是我们设置的 “收件人昵称”，是因为很多邮件服务商在显示邮件时，会把收件人名字自动替换为用户注册的名字，这无伤大雅。添加抄送，暗送12345678# ccto_list 抄送# bccto_list 暗送msg[&apos;from&apos;] = usermsg[&apos;to&apos;] = &apos;,&apos;.join(to_list) #注意，不是分号msg[&apos;cc&apos;] = &apos;,&apos;.join(ccto_list)msg[&apos;subject&apos;] = subjectserver.sendmail(sender,to_list+ccto_list+bccto_list, str(msg))发送HTML邮件要发送HTML邮件很简单，在构造 MIMEText 对象时，把HTML字符串传进去，再把第二个参数由 plain 变为 html ，如下：123msg = MIMEText(&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&apos; + &apos;&lt;p&gt;send by &lt;a href=&quot;http://blog.pangao.vip&quot;&gt;PanGao’s blog&lt;/a&gt;...&lt;/p&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;, &apos;html&apos;, &apos;utf-8&apos;)发送附件要想发送附件，需要构造一个 MIMEMultipart 对象代表邮件本身，然后往里面加上一个 MIMEText 作为邮件正文，再继续往里面加上表示附件的 MIMEBase 对象，如下：1234567891011121314151617181920212223242526from email.mime.multipart import MIMEMultipartfrom email.mime.base import MIMEBase# 邮件对象:msg = MIMEMultipart()msg[&apos;From&apos;] = _format_addr(&apos;发件人昵称 &lt;%s&gt;&apos; % from_addr)msg[&apos;To&apos;] = _format_addr(&apos;收件人昵称 &lt;%s&gt;&apos; % to_addr)msg[&apos;Subject&apos;] = Header(&apos;这是个有主题的邮件&apos;, &apos;utf-8&apos;).encode()# 邮件正文是MIMEText:msg.attach(MIMEText(&apos;send with file...&apos;, &apos;plain&apos;, &apos;utf-8&apos;))# 添加附件就是加上一个MIMEBase，从本地读取一个图片:with open(&apos;/Users/pangao/Downloads/test.png&apos;, &apos;rb&apos;) as f: # 设置附件的MIME和文件名，这里是png类型: mime = MIMEBase(&apos;image&apos;, &apos;png&apos;, filename=&apos;test.png&apos;) # 加上必要的头信息: mime.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&apos;test.png&apos;) mime.add_header(&apos;Content-ID&apos;, &apos;&lt;0&gt;&apos;) mime.add_header(&apos;X-Attachment-Id&apos;, &apos;0&apos;) # 把附件的内容读进来: mime.set_payload(f.read()) # 用Base64编码: encoders.encode_base64(mime) # 添加到MIMEMultipart: msg.attach(mime)发送图片由于 mac 自带的邮件会自动把图片附件插入邮件正文中，所以样式很好看。但是普通邮件可能没这么便捷（抱歉，我没见过普通邮件。。。小小得瑟一下）如果要把一个图片嵌入到邮件正文中怎么做？直接在HTML邮件中链接图片地址行不行？答案是，大部分邮件服务商都会自动屏蔽带有外链的图片，因为不知道这些链接是否指向恶意网站。要把图片嵌入到邮件正文中，我们只需按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用 src=&quot;cid:0&quot; 就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的 cid:x 即可。把上面代码加入 MIMEMultipart 的 MIMEText 从 plain 改为 html，然后在适当的位置引用图片，如下：123msg.attach(MIMEText(&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&apos; + &apos;&lt;p&gt;&lt;img src=&quot;cid:0&quot;&gt;&lt;/p&gt;&apos; + &apos;&lt;/body&gt;&lt;/html&gt;&apos;, &apos;html&apos;, &apos;utf-8&apos;))同时支持HTML和Plain格式如果我们发送HTML邮件，收件人通过浏览器或者Outlook之类的软件是可以正常浏览邮件内容的，但是，如果收件人使用的设备太古老，查看不了HTML邮件怎么办？办法是在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。利用 MIMEMultipart 就可以组合一个HTML和Plain，要注意指定subtype是 alternative，如下：12345678msg = MIMEMultipart(&apos;alternative&apos;)msg[&apos;From&apos;] = ...msg[&apos;To&apos;] = ...msg[&apos;Subject&apos;] = ...msg.attach(MIMEText(&apos;hello&apos;, &apos;plain&apos;, &apos;utf-8&apos;))msg.attach(MIMEText(&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;, &apos;html&apos;, &apos;utf-8&apos;))# 正常发送msg对象...加密SMTP使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。某些邮件服务商，例如Gmail，提供的SMTP服务必须要加密传输。我们来看看如何通过Gmail提供的安全SMTP发送邮件。必须知道，Gmail的SMTP端口是587，因此，修改代码如下：1234567smtp_server = &apos;smtp.gmail.com&apos;smtp_port = 587server = smtplib.SMTP(smtp_server, smtp_port)server.starttls()# 剩下的代码和前面的一模一样:server.set_debuglevel(1)...只需要在创建 SMTP 对象后，立刻调用 starttls() 方法，就创建了安全连接。后面的代码和前面的发送邮件代码完全一样。POP3收取邮件Python内置一个 poplib 模块，实现了POP3协议，可以直接用来收邮件。注意到POP3协议收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。要把POP3收取的文本变成可以阅读的邮件，还需要用email模块提供的各种类来解析原始文本，变成可阅读的邮件对象。所以，收取邮件分两步：第一步：用 poplib 把邮件的原始文本下载到本地；第二部：用 email 解析原始文本，还原为邮件对象。通过POP3下载邮件POP3协议本身很简单，以下面的代码为例，我们来获取最新的一封邮件内容：12345678910111213141516171819202122232425262728293031323334from email.parser import Parserimport poplib# 输入邮件地址, 口令和POP3服务器地址:email = &apos;pangao1990@qq.com&apos;password = &apos;Password&apos;pop3_server = &apos;pop.qq.com&apos;# 连接到POP3服务器:server = poplib.POP3_SSL(pop3_server)# 可以打开或关闭调试信息:server.set_debuglevel(1)# 身份认证:server.user(email)server.pass_(password)# list()返回所有邮件的编号:resp, mails, octets = server.list()# 获取最新一封邮件, 注意索引号从1开始:index = len(mails)resp, lines, octets = server.retr(index)# lines存储了邮件的原始文本的每一行,# 可以获得整个邮件的原始文本:msg_content = b&apos;\r\n&apos;.join(lines).decode(&apos;utf-8&apos;)# 稍后解析出邮件:msg = Parser().parsestr(msg_content)# 可以根据邮件索引号直接从服务器删除邮件:# server.dele(index)# 关闭连接:server.quit()但是这个 Message 对象本身可能是一个 MIMEMultipart 对象，即包含嵌套的其他 MIMEBase 对象，嵌套可能还不止一层。所以我们要递归地打印出 Message 对象的层次结构：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from email.header import decode_headerfrom email.utils import parseaddrdef print_info(msg, indent=0): if indent == 0: for header in [&apos;From&apos;, &apos;To&apos;, &apos;Subject&apos;]: value = msg.get(header, &apos;&apos;) if value: if header == &apos;Subject&apos;: value = decode_str(value) else: hdr, addr = parseaddr(value) name = decode_str(hdr) value = u&apos;%s &lt;%s&gt;&apos; % (name, addr) print(&apos;%s%s: %s&apos; % (&apos; &apos; * indent, header, value)) if (msg.is_multipart()): parts = msg.get_payload() for n, part in enumerate(parts): print(&apos;%spart %s&apos; % (&apos; &apos; * indent, n)) print(&apos;%s--------------------&apos; % (&apos; &apos; * indent)) print_info(part, indent + 1) else: content_type = msg.get_content_type() if content_type == &apos;text/plain&apos; or content_type == &apos;text/html&apos;: content = msg.get_payload(decode=True) charset = guess_charset(msg) if charset: content = content.decode(charset) print(&apos;%sText: %s&apos; % (&apos; &apos; * indent, content + &apos;...&apos;)) else: print(&apos;%sAttachment: %s&apos; % (&apos; &apos; * indent, content_type))def decode_str(s): value, charset = decode_header(s)[0] if charset: value = value.decode(charset) return valuedef guess_charset(msg): charset = msg.get_charset() if charset is None: content_type = msg.get(&apos;Content-Type&apos;, &apos;&apos;).lower() pos = content_type.find(&apos;charset=&apos;) if pos &gt;= 0: charset = content_type[pos + 8:].strip() return charsetprint_info(msg) #解析# From: 木叶 &lt;pangao1990@qq.com&gt;# To: &lt;mail@pangao.vip&gt;# Subject: 测试主题# Text: 测试内容# # ...]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中关于++和—（自增和自减）的理解]]></title>
    <url>%2FPython%E4%B8%AD%E5%85%B3%E4%BA%8E%2B%2B%E5%92%8C%E2%80%94%EF%BC%88%E8%87%AA%E5%A2%9E%E5%92%8C%E8%87%AA%E5%87%8F%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先要知道的是，Python 中是没有 ++ 和 -- 的。那么要实现自增和自减的话，可以使用如下操作：123a = a + 1或a += 1原因分析我们知道， python中的数字类型是不可变数据。也就是数字类型数据在 内存 中是不会发生改变，当变量值发生改变时，会新申请一块内存赋值为新值，然后将变量指向新的内存地址。实验如下：123456&gt;&gt;&gt; a = 10&gt;&gt;&gt; id(a)140530470127960&gt;&gt;&gt; a += 1&gt;&gt;&gt; id(a)140530470129080可以看到当 a 的值发生改变时，a 指向的内存地址也发生了改变。而在C语言中，a 指向的内存地址并不会发生改变，而是改变内存的内容。+= 是改变变量，相当于重新生成一个变量，把操作后的结果赋予这个新生成的变量。++ 是改变了对象本身，而不是变量本身，即改变数据地址所指向的内存中的内容。既然 Python 中的数字类型是不可变的，那何来的“自增”这么一说呢？另外：int 理论上是每次赋值都创建一个新对象的。但是由于使用频繁，为了提升性能避免浪费，所有 python 有个 整数池，默认 [-5, 256] 的数字都属于这个整数池，这些每次赋值的时候，是取得池中的整数对象。但是其他的除外，如下：123456789101112131415&gt;&gt;&gt; a = 5&gt;&gt;&gt; b = 5&gt;&gt;&gt; id(a)140530470128360&gt;&gt;&gt; id(b)140530470128360&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; c = 257&gt;&gt;&gt; d = 257&gt;&gt;&gt; id(c)140530470136432&gt;&gt;&gt; id(d)140530470136408但：有时候在 Python 中看到存在 ++i 这种形式，这其实不是自增，只是简单的表示正负数的正号而已。正正得正，负负得正，所以 ++i 和 --i 都是 i 。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python使用内置urllib模块或第三方库requests访问网络资源]]></title>
    <url>%2FPython%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AEurllib%E6%A8%A1%E5%9D%97%E6%88%96%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93requests%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Python 访问网络资源有很多方法，urllib, urllib2, urllib3, httplib, httplib2, requests ，现介绍如下两种方法：内置的 urllib 模块优点：自带模块，无需额外下载第三方库缺点：操作繁琐，缺少高级功能第三方库 requests优点：处理URL资源特别方便缺点：需要下载安装第三方库内置的 urllib 模块发起GET请求主要使用urlopen()方法来发起请求，如下：1234from urllib import requestresp = request.urlopen(&apos;http://www.baidu.com&apos;)print(resp.read().decode())访问的结果会是一 个http.client.HTTPResponse 对象，使用此对象的 read() 方法，则可以获取访问网页获得的数据。但是要注意的是，获得的数据会是 bytes 的二进制格式，所以需要 decode() 一下，转换成字符串格式。发起POST请求urlopen() 默认的访问方式是GET，当在 urlopen() 方法中传入data参数时，则会发起POST请求。注意：传递的data数据需要为bytes格式。设置timeout参数还可以设置超时时间，如果请求时间超出，那么就会抛出异常。如下：1234from urllib import requestresp = request.urlopen(&apos;http://www.baidu.com&apos;, data=b&apos;word=hello&apos;, timeout=10)print(resp.read().decode())添加Headers通过 urllib 发起的请求会有默认的一个Headers：”User-Agent”:”Python-urllib/3.6”，指明请求是由 urllib 发送的。所以遇到一些验证User-Agent的网站时，我们需要自定义Headers，而这需要借助于urllib.request中的 Request 对象。123456789from urllib import requesturl = &apos;http://httpbin.org/get&apos;headers = &#123;&apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&apos;&#125;# 需要使用url和headers生成一个Request对象，然后将其传入urlopen方法中req = request.Request(url, headers=headers)resp = request.urlopen(req)print(resp.read().decode())Request对象如上所示， urlopen() 方法中不止可以传入字符串格式的url，也可以传入一个 Request 对象来扩展功能，Request 对象如下：1234class urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)构造 Request 对象必须传入url参数，data数据和headers都是可选的。最后， Request 方法可以使用method参数来自由选择请求的方法，如PUT，DELETE等等，默认为GET。添加Cookie为了在请求时能带上Cookie信息，我们需要重新构造一个opener。使用request.build_opener方法来进行构造opener，将我们想要传递的cookie配置到opener中，然后使用这个opener的open方法来发起请求。如下：12345678910111213141516from http import cookiejarfrom urllib import requesturl = &apos;https://www.baidu.com&apos;# 创建一个cookiejar对象cookie = cookiejar.CookieJar()# 使用HTTPCookieProcessor创建cookie处理器cookies = request.HTTPCookieProcessor(cookie)# 并以它为参数创建Opener对象opener = request.build_opener(cookies)# 使用这个opener来发起请求resp = opener.open(url)# 查看之前的cookie对象，则可以看到访问百度获得的cookiefor i in cookie: print(i)或者也可以把这个生成的opener使用install_opener方法来设置为全局的。则之后使用urlopen方法发起请求时，都会带上这个cookie。123# 将这个opener设置为全局的openerrequest.install_opener(opener)resp = request.urlopen(url)设置Proxy代理使用爬虫来爬取数据的时候，常常需要使用代理来隐藏我们的真实IP。如下：1234567891011from urllib import requesturl = &apos;http://www.baidu.com&apos;proxy = &#123;&apos;http&apos;:&apos;222.222.222.222:80&apos;,&apos;https&apos;:&apos;222.222.222.222:80&apos;&#125;# 创建代理处理器proxies = request.ProxyHandler(proxy)# 创建opener对象opener = request.build_opener(proxies)resp = opener.open(url)print(resp.read().decode())下载数据到本地在我们进行网络请求时常常需要保存图片或音频等数据到本地，一种方法是使用python的文件操作，将read()获取的数据保存到文件中。而urllib提供了一个urlretrieve()方法，可以简单的直接将请求获取的数据保存成文件。如下：1234from urllib import requesturl = &apos;http://python.org/&apos;request.urlretrieve(url, &apos;python.html&apos;)urlretrieve() 方法传入的第二个参数为文件保存的位置，以及文件名。注意：urlretrieve() 方法是python2直接移植过来的方法，以后有可能在某个版本中弃用。第三方库 requests安装由于 requests是第三方库，所以要先安装，如下：1pip install requests发起GET请求直接用 get 方法，如下：12345import requestsr = requests.get(&apos;http://www.baidu.com/&apos;)print(r.status_code) #状态print(r.text) #内容对于带参数的URL，传入一个dict作为params参数，如下：12345import requestsr = requests.get(&apos;http://www.baidu.com/&apos;, params=&#123;&apos;q&apos;: &apos;python&apos;, &apos;cat&apos;: &apos;1001&apos;&#125;)print(r.url) #实际请求的URLprint(r.text)requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取，如下：1234r = requests.get(&apos;https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json&apos;)r.json()# &#123;&apos;query&apos;: &#123;&apos;count&apos;: 1, &apos;created&apos;: &apos;2017-11-17T07:14:12Z&apos;, ...添加Headers需要传入HTTP Header时，我们传入一个dict作为headers参数，如下：1r = requests.get(&apos;https://www.baidu.com/&apos;, headers=&#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit&apos;&#125;)获取响应头，如下：12345r.headers# &#123;Content-Type&apos;: &apos;text/html; charset=utf-8&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;, ...&#125;r.headers[&apos;Content-Type&apos;]# &apos;text/html; charset=utf-8&apos;发起POST请求要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据，如下：1r = requests.post(&apos;https://accounts.baidu.com/login&apos;, data=&#123;&apos;form_email&apos;: &apos;abc@example.com&apos;, &apos;form_password&apos;: &apos;123456&apos;&#125;)requests默认使用application/x-www-form-urlencoded对POST数据编码。如果要传递JSON数据，可以直接传入json参数，如下：12params = &#123;&apos;key&apos;: &apos;value&apos;&#125;r = requests.post(url, json=params) #内部自动序列化为JSON上传文件上传文件需要更复杂的编码格式，但是requests把它简化成files参数，如下：12upload_files = &#123;&apos;file&apos;: open(&apos;report.xls&apos;, &apos;rb&apos;)&#125;r = requests.post(url, files=upload_files)在读取文件时，注意务必使用 &#39;rb&#39; 即二进制模式读取，这样获取的 bytes 长度才是文件的长度。把 post() 方法替换为 put() ， delete() 等，就可以以PUT或DELETE方式请求资源。添加Cookie在请求中传入Cookie，只需准备一个dict传入cookies参数，如下：12cs = &#123;&apos;token&apos;: &apos;12345&apos;, &apos;status&apos;: &apos;working&apos;&#125;r = requests.get(url, cookies=cs)requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie，如下：12r.cookies[&apos;token&apos;]# 12345指定超时要指定超时，传入以秒为单位的timeout参数。超时分为连接超时和读取超时，如下：12345try: # 3.1秒后连接超时，27秒后读取超时 r = requests.get(url, timeout=(3.1, 27))except requests.exceptions.RequestException as e: print(e)超时重连12345678def gethtml(url): i = 0 while i &lt; 3: try: html = requests.get(url, timeout=5).text return html except requests.exceptions.RequestException: i += 1添加代理同添加headers方法，代理参数也要是一个dict，如下：12345678heads = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit&apos;&#125;proxy = &#123; &apos;http&apos;: &apos;http://120.25.253.234:812&apos;, &apos;https&apos; &apos;https://163.125.222.244:8123&apos;&#125;r = requests.get(&apos;https://www.baidu.com/&apos;, headers=heads, proxies=proxy)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python读写文件]]></title>
    <url>%2FPython%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[读文件用 open() 方法打开文件，返回一个文件对象，如下：1f = open(&apos;test.txt&apos;, &apos;r&apos;)r 表示文本文件，rb 表示二进制文件。（默认参数是 r ）如果文件不存在，open() 函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：1234&gt;&gt;&gt; f=open(&apos;test.txt&apos;, &apos;r&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError: [Errno 2] No such file or directory: &apos;test.txt&apos;文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。1f.close()由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现，如下：123456try: f = open(&apos;test.txt&apos;, &apos;r&apos;) print(f.read())finally: if f: f.close()但每次这么写很麻烦，Python引入with语句自动帮我们调用close()方法，如下：12with open(&apos;test.txt&apos;, &apos;r&apos;) as f: print(f.read())python文件对象提供了三个“读”方法： read()、readline() 和 readlines()。每种方法可以接受一个变量以限制每次读取的数据量。read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。如果文件大于可用内存，为了保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。readlines() 之间的差异是后者一次读取整个文件，象 .read() 一样。.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理。readline() 每次只读取一行，通常比readlines() 慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用 readline()。注意： 这三种方法都会把每行末尾的 \n 也读入，因此需要手动去除 \n ，如下：1234with open(&apos;test1.txt&apos;, &apos;r&apos;) as f1: list1 = f1.readlines()for i in range(0, len(list1)): list1[i] = list1[i].rstrip(&apos;\n&apos;) #去除末尾的 \n写文件写文件也是用 open() 函数，不同的是传入标识符 w wb a ab， 如下：123f = open(&apos;test.txt&apos;, &apos;w&apos;) # 若是&apos;wb&apos;就表示写二进制文件f.write(&apos;Hello, world!&apos;)f.close()w 是指：如果没有这个文件，就新建一个；如果有，就把原文件清空再写入新内容。a 是指：如果没有这个文件，就新建一个；如果有，就接在原文件的后面写入新内容。注意： 我们可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：12with open(&apos;test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;)python文件对象提供了两个“写”方法： write() 和 writelines()。write()方法和read()、readline()方法对应，是将字符串写入到文件中。writelines()方法和readlines()方法对应，也是针对列表的操作。它接收一个字符串列表作为参数，将他们写入到文件中，换行符不会自动的加入，因此，需要显式的加入换行符。12345678910f1 = open(&apos;test1.txt&apos;, &apos;w&apos;)f1.writelines([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])# 此时test1.txt的内容为:123f1 = open(&apos;test1.txt&apos;, &apos;w&apos;)f1.writelines([&quot;1\n&quot;, &quot;2\n&quot;, &quot;3\n&quot;])# 此时test1.txt的内容为:# 1# 2 # 3关于open()的mode参数：‘r’：读‘w’：写‘a’：追加‘r+’ == r+w（可读可写，文件若不存在就报错(IOError)）‘w+’ == w+r（可读可写，文件若不存在就创建）‘a+’ ==a+r（可追加可写，文件若不存在就创建）对应的，如果是二进制文件，就都加一个b就好了：‘rb’ ‘wb’ ‘ab’ ‘rb+’ ‘wb+’ ‘ab+’字符编码默认情况下是读取 UTF-8 编码的文本文件，如果要读取其他编码，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：1f = open(&apos;test.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：1f = open(&apos;test.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作目录，如：获取当前工作目录，获取执行命令的位置，路径拼接，路径拆分，文件重命名，删除文件，复制文件]]></title>
    <url>%2FPython%E6%93%8D%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%A6%82%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5%EF%BC%8C%E8%B7%AF%E5%BE%84%E6%8B%86%E5%88%86%EF%BC%8C%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D%EF%BC%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[获取当前工作目录获取执行命令的位置路径拼接路径拆分文件重命名删除文件复制文件遍历文件夹下的文件判断文件是否存在判断目录是否存在获取当前工作目录123import sysprint(sys.path[0]) # 获取当前工作目录获取当前脚本名123import sysprint(sys.argv[0]) # 当前脚本名获取执行命令的位置123import osprint(os.getcwd()) # 获取执行命令的位置获取路径的目录123import osprint(os.path.dirname(path)) # 去掉文件名，返回目录路径拼接由于不同的操作系统的路径分隔符不同，因此在做路径拼接时不要直接拼接字符串，而是通过 os.path.join() 函数，如下：12345import osos.path.join(&apos;/Users/pangao&apos;, &apos;test.txt&apos;)# /Users/pangao/test.txt&apos;路径拼接分割符由于不同的操作系统的路径分隔符不同，而 os.sep 可以表示不同操作系统的路径分隔符。如下：1234567import os&apos;hello&apos; + os.sep + &apos;world&apos;# oros.sep.join(&apos;hello&apos;, &apos;world&apos;) # hello/world&apos;路径拆分同理，使用 os.path.split() 函数拆分路径，如下：12345import osos.path.split(&apos;/Users/pangao/test.txt&apos;)# (&apos;/Users/pangao/&apos;, &apos;test.txt&apos;)os.path.splitext() 可以直接获取文件扩展名，很方便，如下：12345import osos.path.splitext(&apos;/Users/pangao/test.txt&apos;)# (&apos;/Users/pangao/test&apos;, &apos;.txt&apos;)这些合并、拆分路径的函数并不会检测目录和文件是否真实存在，他们仅仅是对字符串进行操作。文件重命名假定当前目录下有一个 test.txt 文件，如下：123import osos.rename(&apos;test.txt&apos;, &apos;test.py&apos;) #重命名删除文件假定当前目录下有一个 test.txt 文件，如下：123import osos.remove(&apos;test.txt&apos;) #删除复制文件os 模块中没有复制函数，幸运的是shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充，如下：123import shutilshutil.copyfile(&apos;test.txt&apos;, &apos;test.py&apos;)遍历文件夹下的文件方法1：使用 os.listdir 获取当前目录下的文件和文件夹，如下：1234import osfor filename in os.listdir(&apos;./&apos;): print(filename)方法2：使用 glob 模块，可以设置文件过滤，如下：1234import globfor filename in glob.glob(&apos;*.py&apos;): print(filename)方法3：通过 os.walk ，可以访问子文件夹，如下：12345import osfor fpathe, dirs, fs in os.walk(&apos;./&apos;): for f in fs: print(os.path.join(fpathe, f))判断文件是否存在123import osos.path.isfile(&apos;test.txt&apos;) # 如果不存在就返回False判断目录是否存在123import osos.path.exists(directory) #如果目录不存在就返回False]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中用OpenPyXL处理Excel表格]]></title>
    <url>%2FPython%E4%B8%AD%E7%94%A8OpenPyXL%E5%A4%84%E7%90%86Excel%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言用 Python 处理Excel表格的几个常规库：xlrd 用来读xlwt 用来写xlutils 用于做复制、筛选等针对文档文件的操作这些库都不如 OpenPyXL 强大，OpenPyXL 即可以读也可以写 Excel 2010+ 的 xlsx xlsm xltx xltm 文件。不过， OpenPyXL 库也是比较吃内存的，大约是原始文件的50倍左右。例如，一个50M大小的Excel文件，需要2.5G大小的内存运行。关于以上几个库的性能比对，请移步 OpenPyXL性能测试。安装在终端中输入命令，如下：1pip install openpyxlopenpyxl 在保存Excel表格时候会丢失原文件的图片和图表。如果要操作图片，则需要 pillow 库，安装如下：1pip install pillow由于最近军运会要在天朝举行，因此必须翻-墙才能安装。使用方法新建Excel表格新建Excel表格，默认有一个名为 Sheet 的表格，如下：123456from openpyxl import Workbookwb = Workbook() #创建文件对象ws = wb.active #获取默认sheetwb.save(&quot;sample.xlsx&quot;)打开已有的Excel表格对已有的Excel表格进行操作，如下：12345from openpyxl import Workbook, load_workbookwb = load_workbook(&apos;sample.xlsx&apos;)wb.save(&quot;sample.xlsx&quot;)新建/获取Sheet表格使用 Workbook.create_sheet() 方法新建Sheet表格。第一个参数是sheet名称，若不填，则默认以 Sheet1 Sheet2 Sheet3 …方式命名；第二个参数是插入Sheet表格的位置，以 0 为第一个位置，若不填，则置于最后。如下：12345ws1 = wb.create_sheet(&quot;Mysheet&quot;) #默认在最后插入ws2 = wb.create_sheet(&quot;Mysheet&quot;, 0) #在第一个位置插入wb.remove(ws1) #删除sheet也可以后期随时修改sheet的名字，如下：1ws.title = &quot;New Title&quot;修改sheet标签颜色，如下：1ws.sheet_properties.tabColor = &quot;1072BA&quot;若知道sheet的名字，可以用如下方式获取sheet ：1234ws = wb.get_sheet_by_name(&quot;New Title&quot;)ws = wb[&quot;New Title&quot;]也可获取全部sheet的名字，遍历sheet名字，如下：12345678910 sheets = wb.sheetnames for sheet in sheets: print(sheets)for sheet in wb: print sheet.title [&apos;Sheet1&apos;, &apos;New Title&apos;, &apos;Sheet2&apos;]也可以定位到相应sheet页,[0]为sheet页索引，如下：12sheet_names = wb.sheetnames # 获取所有sheet页名字ws = wb[sheet_names[0]]复制Sheet表格仅能复制 单元格的值 样式 超链接 注释块 等，而 图片 和 表格 等是无法复制的，如下：12source = wb.activetarget = wb.copy_worksheet(source)操作单元格由 worksheet 获取单元格，或直接给单元格赋值，如下：123456cell = ws[&apos;A4&apos;] #获取第4行第A列的单元格ws[&apos;A4&apos;] = 4 #给第4行第A列的单元格赋值为4ws.cell(row=4, column=2, value=10) #给第4行第2列的单元格赋值为10ws.cell(4, 2, 10) #同上获取区域内的单元格，如下：123456cell_range = ws[&apos;A1&apos;:&apos;C2&apos;] #获取A1-C2内的区域colC = ws[&apos;C&apos;] #获取第C列col_range = ws[&apos;C:D&apos;] #获取第C-D列row10 = ws[10] #获取第10列row_range = ws[5:10] #获取第5-10列如果得到单元格，可以赋值，如下：123cell.value = &apos;hello, world&apos;或cell = ws.cell(row=i, column=j, value=&quot;金额&quot;)获取单元格的值，如下：1cellValue = ws.cell(row=i, column=j).value获取行列数，如下：12row = ws.max_row #最大行数column = ws.max_column #最大列数一行行的获取数据，如下：12345678910&gt;&gt;&gt; for row in ws.iter_rows(min_row=1, max_col=3, max_row=2):... for cell in row:... print(cell)&lt;Cell Sheet1.A1&gt;&lt;Cell Sheet1.B1&gt;&lt;Cell Sheet1.C1&gt;&lt;Cell Sheet1.A2&gt;&lt;Cell Sheet1.B2&gt;&lt;Cell Sheet1.C2&gt;一列列的获取数据，如下：123456789&gt;&gt;&gt; for col in ws.iter_cols(min_row=1, max_col=3, max_row=2):... for cell in col:... print(cell)&lt;Cell Sheet1.A1&gt;&lt;Cell Sheet1.A2&gt;&lt;Cell Sheet1.B1&gt;&lt;Cell Sheet1.B2&gt;&lt;Cell Sheet1.C1&gt;&lt;Cell Sheet1.C2&gt;因为性能的原因， Worksheet.iter_cols() 方法不能在只读模式下使用。获取所有的列或行，如下：123rows = ws.rowscolumns = ws.columns因为性能的原因， Worksheet.columns 方法不能在只读模式下使用。如果只想从worksheet中获取值，可以使用 Worksheet.values 属性，如下：123for row in ws.values: for value in row: print(value)Worksheet.iter_rows() 和 Worksheet.iter_cols() 方法都可以添加 values_only 参数来达到仅获取值的目的，如下：12for row in ws.iter_rows(min_row=1, max_col=3, max_row=2, values_only=True): print(row)保存文件使用 Workbook.save() 方法保存workbook，这个方法会不加提示的覆盖原文件，如下：12wb = Workbook()wb.save(&apos;balances.xlsx&apos;)获取单元格类型1234567891011121314151617181920212223242526272829from openpyxl import Workbook, load_workbookimport datetimewb = load_workbook(&apos;sample.xlsx&apos;)ws=wb.activewb.guess_types = True #开启获取单元格类型ws[&quot;A1&quot;]=datetime.datetime(2010, 7, 21)print ws[&quot;A1&quot;].number_formatws[&quot;A2&quot;]=&quot;12%&quot;print ws[&quot;A2&quot;].number_formatws[&quot;A3&quot;]= 1.1print ws[&quot;A4&quot;].number_formatws[&quot;A4&quot;]= &quot;中国&quot;print ws[&quot;A5&quot;].number_formatwb.save(&quot;sample.xlsx&quot;)# 执行结果：# yyyy-mm-dd h:mm:ss# 0%# General# General# 如果是常规，显示general,如果是数字，显示&apos;0.00_ &apos;，如果是百分数显示0%# 数字需要在Excel中设置数字类型，直接写入的数字是常规类型使用公式12345678910111213141516from openpyxl import Workbook, load_workbookwb = load_workbook(&apos;sample.xlsx&apos;)ws1=wb.activews1[&quot;A1&quot;]=1ws1[&quot;A2&quot;]=2ws1[&quot;A3&quot;]=3ws1[&quot;A4&quot;] = &quot;=SUM(1, 1)&quot;ws1[&quot;A5&quot;] = &quot;=SUM(A1:A3)&quot;print ws1[&quot;A4&quot;].value #打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值print ws1[&quot;A5&quot;].value #打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值wb.save(&quot;sample.xlsx&quot;)合并单元格12345678910111213from openpyxl import Workbook, load_workbookwb = load_workbook(&apos;sample.xlsx&apos;)ws1=wb.activews.merge_cells(&apos;A2:D2&apos;)ws.unmerge_cells(&apos;A2:D2&apos;) #合并后的单元格，脚本单独执行拆分操作会报错，需要重新执行合并操作再拆分# or equivalentlyws.merge_cells(start_row=2,start_column=1,end_row=2,end_column=4)ws.unmerge_cells(start_row=2,start_column=1,end_row=2,end_column=4)wb.save(&quot;sample.xlsx&quot;)插入一个图片需要 pillow 库，安装如下：1pip install pillow12345678910from openpyxl import load_workbookfrom openpyxl.drawing.image import Imagewb = load_workbook(&apos;sample.xlsx&apos;)ws1=wb.activeimg = Image(&apos;1.png&apos;)ws1.add_image(img, &apos;A1&apos;)wb.save(&quot;sample.xlsx&quot;)隐藏单元格123456789101112from openpyxl import load_workbookwb = load_workbook(&apos;sample.xlsx&apos;)ws = wb.activews.column_dimensions.group(&apos;A&apos;, &apos;D&apos;, hidden=True) # 隐藏A到D列ws.row_dimensions.group(1, 10, hidden=True) # 隐藏1到10行ws.row_dimensions[2].hidden # 获取第二行是否隐藏了wb.save(&quot;sample.xlsx&quot;)优化模式在处理非常大的 XLSX 文件时，openpyxl 的常规模式无法处理这种负载。幸运的是，有两种模式可以在(几乎)恒定内存消耗的情况下读写无限量的数据。只读模式1234567from openpyxl import load_workbookwb = load_workbook(filename=&apos;large_file.xlsx&apos;, read_only=True)ws = wb[&apos;big_data&apos;]for row in ws.rows: for cell in row: print(cell.value)只写模式12345678910from openpyxl import Workbookwb = Workbook(write_only=True)ws = wb.create_sheet()# now we&apos;ll fill it with 100 rows x 200 columnsfor irow in range(100):... ws.append([&apos;%d&apos; % i for i in range(200)])# save the filewb.save(&apos;new_big_file.xlsx&apos;) # doctest: +SKIP与普通工作簿不同，新创建的只写工作簿不包含任何工作表；必须使用 create_sheet() 方法专门创建工作表。在只写的工作簿中，只能使用 append() 添加行。使用 cell() 或 iter_rows() 在任意位置写(或读)单元格是不可能的。它能够导出无限数量的数据(甚至比Excel实际能够处理的更多)，同时将内存使用量保持在10Mb以下。插入/删除行/列，移动区域单元格插入行/列在第7行之上插入一行，如下：1ws.insert_rows(7)在第7列的左边插入一列，如下：1ws.insert_cols(7)删除行/列从第6列开始，删除3列，即删除6、7、8列，如下：1ws.delete_cols(6, 3)移动区域单元格将 D4:F10 区域向上移动一行向右移动2列，如下：1ws.move_range(&quot;D4:F10&quot;, rows=-1, cols=2)如果区域内包含 公式 ，则如下方法可以连同公式一起挪动：1ws.move_range(&quot;G4:H10&quot;, rows=1, cols=1, translate=True)使用 Pandas 和 NumPy详情请移步 Working with Pandas and NumPy图表图表由至少一个系列的一个或多个单元格区域数据点组成。更多内容请移步 图表介绍注释openpyxl 可读/写注释，但格式信息会被丢失。在 只读模式 下不支持操作注释。注释必须包括 内容 和 作者 。读注释，如下：123comment = ws[&quot;A1&quot;].commentcomment.text # 注释内容comment.author # 注释作者写注释，如下：12345comment = Comment(&quot;Text&quot;, &quot;Author&quot;)comment.width = 300 # 设置宽度comment.height = 50 # 设置高度ws[&quot;A1&quot;].comment = commentws[&quot;B2&quot;].comment = comment表格样式字体样式字体名称、字体大小、字体颜色、加粗、斜体、纵向对齐方式（有三种：baseline，superscript， subscript）、下划线、删除线，如下：1234567891011121314from openpyxl.styles import Fontfont = Font(name=&apos;Calibri&apos;, size=11, color=&apos;FF000000&apos;, bold=False, italic=False, vertAlign=None, underline=&apos;none&apos;, strike=False)ws[&apos;A1&apos;].font = fontcell2.font = Font(name=cell1.font.name, sz=cell1.font.sz, b=cell1.font.b, i=cell1.font.i)字体颜色可以用 RGB 或 aRGB ，如下：123font = Font(color=&quot;FFBB00&quot;)font = Font(color=&quot;FFFFBB00&quot;)继承并重写样式，如下：123ft1 = Font(name=&apos;Arial&apos;, size=14)ft2 = copy(ft1)ft2.name = &quot;Tahoma&quot;填充样式详情请移步 填充样式1234from openpyxl.styles import PatternFill# fill_type 的样式为 None 或 solidcell2.fill = PatternFill(fill_type=cell1.fill.fill_type, fgColor=cell1.fill.fgColor)边框样式详情请移步 边框样式123456789101112from openpyxl.styles import Border, Sideborder = Border(left=Side(border_style=None, color=&apos;FF000000&apos;), right=Side(border_style=None, color=&apos;FF000000&apos;), top=Side(border_style=None, color=&apos;FF000000&apos;), bottom=Side(border_style=None, color=&apos;FF000000&apos;), diagonal=Side(border_style=None, color=&apos;FF000000&apos;), diagonal_direction=0, outline=Side(border_style=None, color=&apos;FF000000&apos;), vertical=Side(border_style=None, color=&apos;FF000000&apos;), horizontal=Side(border_style=None, color=&apos;FF000000&apos;))对齐样式horizontal 的值有：distributed, justify, center, left, fill, centerContinuous, right, generalvertical 的值有：bottom, distributed, justify, center, top12345678from openpyxl.styles import Alignmentalignment=Alignment(horizontal=&apos;general&apos;, vertical=&apos;bottom&apos;, text_rotation=0, wrap_text=False, shrink_to_fit=False, indent=0)保护样式锁定、隐藏123from openpyxl.styles import Protectionprotection = Protection(locked=True, hidden=False)整行或整列应用样式1234col = ws.column_dimensions[&apos;A&apos;]col.font = Font(bold=True)row = ws.row_dimensions[1]row.font = Font(underline=&quot;single&quot;)更改合并的单元格样式合并的单元格可以想想成为左上角的那个单元格来操作。筛选和排序12345678910111213141516171819202122232425262728293031from openpyxl import Workbookwb = Workbook()ws = wb.activedata = [ [&quot;Fruit&quot;, &quot;Quantity&quot;], [&quot;Kiwi&quot;, 3], [&quot;Grape&quot;, 15], [&quot;Apple&quot;, 3], [&quot;Peach&quot;, 3], [&quot;Pomegranate&quot;, 3], [&quot;Pear&quot;, 3], [&quot;Tangerine&quot;, 3], [&quot;Blueberry&quot;, 3], [&quot;Mango&quot;, 3], [&quot;Watermelon&quot;, 3], [&quot;Blackberry&quot;, 3], [&quot;Orange&quot;, 3], [&quot;Raspberry&quot;, 3], [&quot;Banana&quot;, 3]]for r in data: ws.append(r)ws.auto_filter.ref = &quot;A1:B15&quot;ws.auto_filter.add_filter_column(0, [&quot;Kiwi&quot;, &quot;Apple&quot;, &quot;Mango&quot;])ws.auto_filter.add_sort_condition(&quot;B2:B15&quot;)wb.save(&quot;filtered.xlsx&quot;)生成的Excel表格，有筛选排序的操作，但是没有实际表现出效果，如下图：需要手动点击 重写应用 才能显示出效果，如下图：密码保护该功能仅能提供一个很基础的密码保护，没有进行加密处理，网上普通的破解软件都可以破解密码。不过，日常使用还是可以的。该功能仅可用于新建excel表格，不能用于已存在的excel表格。workbook工作薄保护防止查看隐藏sheet，避免增加、移动、删除、隐藏或重命名sheet等操作，可以保护workbook的结构，如下：12wb.security.workbookPassword = &apos;...&apos;wb.security.lockStructure = Trueworksheet保护worksheet保护不需要密码，如下：12ws = wb.activewb.protection.sheet = Trueopenpyxl包文件更多详情请移步 openpyxl package]]></content>
      <categories>
        <category>Python</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决MacOS系统升级时显示安装所选更新时发生错误的问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3MacOS%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7%E6%97%B6%E6%98%BE%E7%A4%BA%E5%AE%89%E8%A3%85%E6%89%80%E9%80%89%E6%9B%B4%E6%96%B0%E6%97%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[按照Mac提示系统更新，不曾想出问题了，安装所选更新时发生错误 如下：这是由于Mac SIP系统完整性保护机制导致的，那么现在就关闭这个机制，来升级系统。关闭保护机制先关机再按住 command + R 不要松开，接着按 开机键 (然后松开 开机键 ，但是 command + R 不要松)待看到系统加载进度时，也不要松开 command + R直到进入 恢复模式 ，如下：打开 终端 ，输入 csrutil disable，然后重启系统，如下：重新下载更新重新下载更新，之后提示安装，如下：重开保护机制系统安装好后，重开保护机制。方法和关闭保护机制一样，不同的是，输入 csrutil enable 。]]></content>
      <categories>
        <category>IT实用技能</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-docx处理word文档]]></title>
    <url>%2Fpython-docx%E5%A4%84%E7%90%86word%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[前言全网找了一番，用python创建和更新word(.docx)文档，还是 python-docx 包比较好用。依赖Python 2.6, 2.7, 3.3, or 3.4lxml &gt;= 2.3.2安装模块由于 python-docx 已经提交给 PyPI 仓库，所以可以使用 pip 安装，如下：1pip install python-docx如果同时安装了 python2 和 python3 那么 pip 可能不能用，可以使用 pip3 来安装，如下：1pip3 install python-docxpython-docx 也可以使用 easy_install 来安装，如下：1easy_install python-docx如果不能使用 pip 和 easy_install ，可以在 PyPI 下载包、解压、运行 setup.py ，如下：123tar xvzf python-docx-&#123;version&#125;.tar.gzcd python-docx-&#123;version&#125;python setup.py installpython-docx 还依赖 lxml 包 ，使用前2种方法会自动安装所需依赖包，第三种方法需要自己手动安装。处理word文档新建文档类首先新建一个空白文档类 Document ，如下：123from docx import Documentdocument = Document()编辑已存在的word文档python-docx 不仅可以创建word文档，还可以编辑已存在的word文档。其实吧，这玩意儿只能编辑已存在的word文档，之所以有个“创建空白文档”的功能，只不过是拷贝一份空白word文档到工作区间，再在空白文档上编辑，看起来似乎是“创建空白文档”罢了。本质上还是编辑已存在的word文档，捂脸中…打开一个word文档，编辑完后，一定要记得保存。如果保存文件名和原文件名不一样，则会另存为一份word文档；若文件名一样，则会不加提示的保存修改内容。如下：1234from docx import Documentdocument = Document(&apos;existing-document-file.docx&apos;)document.save(&apos;new-file-name.docx&apos;)新增段落在word中 段落 是最常见的，创建段落 paragraph 的操作如下：1paragraph = document.add_paragraph(&apos;这是个段落。&apos;)在此段落之前插入一个段落，如下：1prior_paragraph = paragraph.insert_paragraph_before(&apos;这是前面的段落。&apos;)新增标题新增标题代码如下：1document.add_heading(&apos;这是个标题&apos;)修改标题大小，有1-9种规格，如下：1document.add_heading(&apos;The role of dolphins&apos;, level=2)如果使用 level=0 ，则会新增一个带有下划线样式的标题。新增分页符代码如下：1document.add_page_break()新增表格创建一个2行2列的表格 Table，如下：1table = document.add_table(rows=2, cols=2)获取第一行第二列的单元格类，如下：1cell = table.cell(0, 1)写入数据，如下：1cell.text = &apos;这是第一行第二列的单元格&apos;不仅如此，还能以数组的形式获取整个行或列，如下：123row = table.rows[1]row.cells[0].text = &apos;第二行第一列&apos;row.cells[1].text = &apos;第二行第二列&apos;或循环操作，如下：123for row in table.rows: for cell in row.cells: print(cell.text)用 len() 方法获取行数或列数，如下：12row_count = len(table.rows)col_count = len(table.columns)增加行，如下：1row = table.add_row()设置表格样式，如下：1table.style = &apos;LightShading-Accent1&apos;插入图片插入本地图片，如下：1document.add_picture(&apos;demo.png&apos;)默认情况下，图片大小往往不尽如人意，调整图片大小，如下：123from docx.shared import Inchesdocument.add_picture(&apos;demo.png&apos;, width=Inches(1.0), height=Inches(1.0))若同时定义宽度和高度，则图片会被拉伸或压缩到指定大小；若仅定义宽度或高度，则图会自适应调整大小。所以，建议仅定义宽度即可。段落操作设置段落样式设置段落样式，如下：1document.add_paragraph(&apos;这是一个样式为 ListBullet 的段落&apos;, style=&apos;ListBullet&apos;)或12paragraph = document.add_paragraph(&apos;这是一个样式为 ListBullet 的段落&apos;)paragraph.style = &apos;List Bullet&apos;设置段落对齐方式段落对齐方式有 左对齐 、 文字居中 、 右对齐 、 文本两端对齐等，更多对齐方式请移步 WD_ALIGN_PARAGRAPH12345678910from docx.enum.text import WD_ALIGN_PARAGRAPH# LEFT =&gt; 左对齐# CENTER =&gt; 文字居中# RIGHT =&gt; 右对齐# JUSTIFY =&gt; 文本两端对齐paragraph = document.add_paragraph(&quot;你说啥&quot;)paragraph_format = paragraph.paragraph_formatparagraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER设置段落缩进设置段落缩进，可为负值，如下：12345from docx.shared import Inchesparagraph = document.add_paragraph(&quot;你说啥&quot;)paragraph_format = paragraph.paragraph_formatparagraph_format.left_indent = Inches(0.5)也可以设置首行缩进，如下：1paragraph_format.first_line_indent = Inches(-0.25)设置段落制表符详情请移步 TabStops设置段落间距分为 段前 和 段后 ，设置值用 Pt 单位是 磅 ，如下：12paragraph_format.space_before = Pt(18)paragraph_format.space_after = Pt(12)设置段落行距当行距为 最小值 和 固定值 时，设置值单位为 磅 ，需要用 Pt ；当行距为 多倍行距 时，设置值为数值，如下：12345678910111213from docx.shared import Length#SINGLE =&gt; 单倍行距（默认）#ONE_POINT_FIVE =&gt; 1.5倍行距#DOUBLE2 =&gt; 倍行距#AT_LEAST =&gt; 最小值#EXACTLY =&gt; 固定值#MULTIPLE =&gt; 多倍行距paragraph.line_spacing_rule = WD_LINE_SPACING.EXACTLY #固定值paragraph_format.line_spacing = Pt(18) # 固定值18磅paragraph.line_spacing_rule = WD_LINE_SPACING.MULTIPLE #多倍行距paragraph_format.line_spacing = 1.75 # 1.75倍行间距设置段落分页孤行控制防止在页面顶端单独打印段落末行或在页面底端单独打印段落首行。与下段同页防止在选中段落与后面一段间插入分页符。段中不分页防止在段落中出现分页符。段前分页在选中段落前插入分页符。123456#widow_control =&gt; 孤行控制#keep_with_next =&gt; 与下段同页#page_break_before =&gt; 段前分页#keep_together =&gt; 段中不分页paragraph_format.keep_with_next = True字体操作设置粗体和斜体在设置粗体和斜体之前，我们先简单了解一下 段落 里的运行机制。段落包含很多块级的格式，比如缩进、行高、制表符等。每一个小片段叫做一个 run ，可以对 run 设置粗体和斜体等属性。我们可以设置如下：123456paragraph = document.add_paragraph()paragraph.add_run(&apos;这是一个带有&apos;)paragraph.add_run(&apos;粗体&apos;).bold = Trueparagraph.add_run(&apos;和&apos;)paragraph.add_run(&apos;斜体&apos;).italic = Trueparagraph.add_run(&apos;的段落。&apos;)设置字体属性对 run 设置字体、大小、颜色下划线等，更多属性请移步 Font ，如下：1234567891011121314151617181920212223242526272829from docx.shared import RGBColor,Pt#all_caps =&gt; 全部大写字母#bold =&gt; 加粗#color =&gt; 字体颜色#complex_script =&gt; 是否为“复杂代码”#cs_bold =&gt; “复杂代码”加粗#cs_italic =&gt; “复杂代码”斜体#double_strike =&gt; 双删除线#emboss =&gt; 文本以凸出页面的方式出现#hidden =&gt; 隐藏#imprint =&gt; 印记#italic =&gt; 斜体#name =&gt; 字体#no_proof =&gt; 不验证语法错误#outline =&gt; 显示字符的轮廓#shadow =&gt; 阴影#small_caps =&gt; 小型大写字母#snap_to_grid =&gt; 定义文档网格时对齐网络#strike =&gt; 删除线#subscript =&gt; 下标#superscript =&gt; 上标#underline =&gt; 下划线paragraph = document.add_paragraph()paragraph.add_run(&apos;这是一个带有&apos;)paragraph.add_run(&apos;颜色&apos;).font.color.rgb = RGBColor(54, 95, 145)paragraph.add_run(&apos;的&apos;)paragraph.add_run(&apos;大字&apos;).font.size = Pt(36) # 字体大小设置，和word里面的字号相对应设置字符样式除了设置段落样式外，还可以设置一组字符样式，比如字体、大小、颜色、粗体、斜体等，如下：12345# 自定义样式 Emphasisparagraph = document.add_paragraph(&apos;这是一个带有&apos;)paragraph.add_run(&apos;自定义样式&apos;, &apos;Emphasis&apos;)paragraph.add_run(&apos;的段落&apos;)或1234paragraph = document.add_paragraph(&apos;这是一个带有 &apos;)run = paragraph.add_run(&apos;自定义样式&apos;)run.style = &apos;Emphasis&apos;paragraph.add_run(&apos;的段落&apos;)页眉和页脚更多内容请移步 Working with Headers and Footers枚举的文档MSO_COLOR_TYPEMSO_THEME_COLOR_INDEXWD_PARAGRAPH_ALIGNMENTWD_BUILTIN_STYLEWD_CELL_VERTICAL_ALIGNMENTWD_COLOR_INDEXWD_LINE_SPACINGWD_ORIENTATIONWD_TABLE_ALIGNMENTWD_ROW_HEIGHT_RULEWD_SECTION_STARTWD_STYLE_TYPEWD_TAB_ALIGNMENTWD_TAB_LEADERWD_TABLE_DIRECTIONWD_UNDERLINE名称解释官网解释]]></content>
      <categories>
        <category>Python</category>
        <category>Word</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[perl处理Excel(跨平台)]]></title>
    <url>%2Fperl%E5%A4%84%E7%90%86Excel(%E8%B7%A8%E5%B9%B3%E5%8F%B0)%2F</url>
    <content type="text"><![CDATA[前言用perl处理excel有两种流行的模块：一种是 win32:OLE 模块，优点是功能强大，在excel上能做的事情用这个模块都能做，缺点是无法跨平台，必须在win系统上使用且必须安装office软件；另一种是 Spreadsheet 模块，优点是跨平台，不依赖系统和软件，缺点是功能不是很多，但基本功能都能实现。如果在win平台处理excel，建议使用 win32:OLE 模块（教程传送门），本文主要讲解 Spreadsheet 模块的使用方法。了解从 Spreadsheet::ParseExcel 和 Spreadsheet::WriteExcel 的官方资料中我们可以知道：Spreadsheet::ParseExcel是用于提取excel信息仅支持Excel 95-2003格式Spreadsheet::WriteExcel是用于新建excel信息仅支持Excel 97-2007格式也就是说，如果想更好的支持 xlsx 格式的excel需要用到 Spreadsheet::ParseXLSX 和 Excel::Writer::XLSX 模块。另外， Spreadsheet::ParseExcel::SaveParser 可以支持在已存在的 xls 表中修改数据，但是支持效果远没有 win32:OLE 模块强大，修改之后的表格会丢失部分不支持的宏命令和表格等，最遗憾的是仅支持 xls ，并不支持 xlsx 。安装模块在终端中输入 sudo perl -MCPAN -e &quot;install &#39;Spreadsheet::ParseExcel&#39;&quot; ，回车，如下图：-1.png)若出现如下图，则安装成功：-2.png)使用方法 - 提取Excel引用 use Spreadsheet::ParseExcel; 类，如下：1use Spreadsheet::ParseExcel;Parsernew()new()方法可以新建一个提取类，如下：1my $parser = Spreadsheet::ParseExcel-&gt;new(); #新建提取类若是2007版以上的excel，则需要用到 Spreadsheet::ParseXLSX ，如下：12use Spreadsheet::ParseXLSX; #引用my $parser = Spreadsheet::ParseXLSX-&gt;new(); #新建xlsx提取类若excel需要密码才能打开，则新建密码提取类，如下：1$parser = Spreadsheet::ParseExcel-&gt;new( Password =&gt; &apos;secret&apos; ); #若excel需要密码才能打开，则新建密码提取类parse($filename)获取excel表的工作薄，若无则返回 under1my $workbook = $parser-&gt;parse(&apos;Book1.xls&apos;); #获取excel表的工作薄，若无则返回 `under`error()判断是否存在该excel表格12345678910# error_code() =&gt; error()# ============ =======# 0 =&gt; &apos;&apos;# 1 =&gt; &apos;文件没有找到&apos;# 2 =&gt; &apos;该文件不是标准的excel格式文档&apos;# 3 =&gt; &apos;文件加密了&apos;if ( !defined $workbook ) &#123; #一般需要判断是否存在该excel表格 die $parser-&gt;error_code(), $parser-&gt;error(), &quot;.\n&quot;;&#125;WorkbookSpreadsheet::ParseExcel::Workbook 是由 Spreadsheet::ParseExcel 的 parse() 方法获得，有如下几种常用方法（完整方法使用传送门）：1234$workbook-&gt;worksheets()$workbook-&gt;worksheet()$workbook-&gt;worksheet_count()$workbook-&gt;get_filename()worksheets()循环获取所有的sheet表，如下：1234for my $worksheet ( $workbook-&gt;worksheets() ) &#123; #循环获取所有的sheet表 ...&#125;worksheet()通过sheet表名或表索引获取单一sheet表，若无则返回 under ，如下：12$worksheet = $workbook-&gt;worksheet(&apos;Sheet1&apos;); #获取名为&quot;Sheet1&quot;的sheet表$worksheet = $workbook-&gt;worksheet(0); #获取第一张sheet表worksheet_count()获取sheet表的个数，如下：1my $worksheet_count = $workbook-&gt;worksheet_count(); #获取sheet表的个数get_filename()获取excel表的全路径+名称，如下：1my $filename = $workbook-&gt;get_filename(); #获取excel表的全路径+名称WorksheetSpreadsheet::ParseExcel::Worksheet 是由 worksheets() 或 worksheet() 方法获得，有如下几种常用方法（完整方法使用传送门）：1234$worksheet-&gt;get_cell()$worksheet-&gt;row_range()$worksheet-&gt;col_range()$worksheet-&gt;get_name()get_cell($row, $col)由指定行和列获取单元格，若不存在则返回 under ，如下：1my $cell = $worksheet-&gt;get_cell($row, $col); #由指定行和列获取单元格row_range()返回一个二元列表 ($min, $max) ，表示行数的最小值和最大值，如下图：1my ( $row_min, $row_max ) = $worksheet-&gt;row_range(); #行数的最小值和最大值col_range()返回一个二元列表 ($min, $max) ，表示列数的最小值和最大值，如下图：1my ( $col_min, $col_max ) = $worksheet-&gt;col_range(); #列数的最小值和最大值get_name()获取sheet的名称，如下图：1my $name = $worksheet-&gt;get_name(); #获取sheet的名称CellSpreadsheet::ParseExcel::Cell 有如下几种常用方法（完整方法使用传送门）：12$cell-&gt;value()$cell-&gt;unformatted()value()获取单元格的值(有格式)。例如，在单元格中输入数字 123 ，单元格显示为 123.00 ， 方法value() 的返回值为 123.00 。如下：1my $value = $cell-&gt;value(); #获取单元格的值(有格式)unformatted()获取单元格的值(无格式)。例如，在单元格中输入数字 123 ，单元格显示为 123.00 ，方法 unformatted() 的返回值为 123 。如下：1my $value = $cell-&gt;unformatted(); #获取单元格的值(有格式)高级方法 - 提取ExcelFormat获取 单元格格式 ，如下：1my $format = $cell-&gt;get_format(); #获取单元格格式Spreadsheet::ParseExcel::Format 类有如下方法：12345678910111213141516$format-&gt;&#123;Font&#125;$format-&gt;&#123;AlignH&#125;$format-&gt;&#123;AlignV&#125;$format-&gt;&#123;Indent&#125;$format-&gt;&#123;Wrap&#125;$format-&gt;&#123;Shrink&#125;$format-&gt;&#123;Rotate&#125;$format-&gt;&#123;JustLast&#125;$format-&gt;&#123;ReadDir&#125;$format-&gt;&#123;BdrStyle&#125;$format-&gt;&#123;BdrColor&#125;$format-&gt;&#123;BdrDiag&#125;$format-&gt;&#123;Fill&#125;$format-&gt;&#123;Lock&#125;$format-&gt;&#123;Hidden&#125;$format-&gt;&#123;Style&#125;$format-&gt;{Font}获取单元格的 字体 ，如下：1my $font = $format-&gt;&#123;Font&#125;$format-&gt;{AlignH}获取单元格的 水平对齐方式 ，返回值如下：123456780 =&gt; 常规1 =&gt; 靠左2 =&gt; 居中3 =&gt; 靠右4 =&gt; 填充5 =&gt; 两端对齐6 =&gt; 跨列居中7 =&gt; 分散对齐$format-&gt;{Indent}获取单元格的 水平对齐方式 中 靠左 的缩进值$format-&gt;{AlignV}获取单元格的 垂直对齐方式 ，返回值如下：123450 =&gt; 靠上1 =&gt; 居中2 =&gt; 靠下3 =&gt; 两端对齐4 =&gt; 分散对齐$format-&gt;{Wrap}是否选择了 文本控制 中的 自动换行$format-&gt;{Shrink}是否选择了 文本控制 中的 缩小字体填充$format-&gt;{Rotate}获取 字体旋转方向 ，如下：12340 =&gt; 无1 =&gt; 垂直2 =&gt; 逆时针90度3 =&gt; 顺时针90度$format-&gt;{JustLast}是否选择了 两端分散对齐$format-&gt;{ReadDir}获取 文本阅读方向$format-&gt;{BdrStyle}获取 边框线型 ，如下数组：1[ $left, $right, $top, $bottom ]$format-&gt;{BdrColor}获取 边框颜色 ，如下数组：1[ $left, $right, $top, $bottom ]$format-&gt;{BdrDiag}获取 对角线边框种类、线型、颜色 ，如下数组：1[$kind, $style, $color ]边框种类如下：12340 =&gt; 无1 =&gt; 右上对角线2 =&gt; 右下对角线3 =&gt; 全部$format-&gt;{Fill}获取 填充 的 图案样式 、 图案颜色 、 背景色 ，如下：1[ $pattern, $front_color, $back_color ]$format-&gt;{Lock}获取是否 锁定 单元格$format-&gt;{Hidden}获取是否 隐藏 公式Font获取单元格的 字体 ，如下：1my $font = $format-&gt;&#123;Font&#125;Spreadsheet::ParseExcel::Font 类有如下方法：123456789$font-&gt;&#123;Name&#125;$font-&gt;&#123;Bold&#125;$font-&gt;&#123;Italic&#125;$font-&gt;&#123;Height&#125;$font-&gt;&#123;Underline&#125;$font-&gt;&#123;UnderlineStyle&#125;$font-&gt;&#123;Color&#125;$font-&gt;&#123;Strikeout&#125;$font-&gt;&#123;Super&#125;$font-&gt;{Name}获取 字体名称 ，如 Arial$font-&gt;{Bold}获取字体是否 加粗$font-&gt;{Italic}获取字体是否 斜体$font-&gt;{Height}获取字体 大小$font-&gt;{Underline}获取字体是否开启 下划线$font-&gt;{UnderlineStyle}获取字体 下划线样式 ，如下：12345 0 =&gt; 无 1 =&gt; 下划线 2 =&gt; 双下划线33 =&gt; Single accounting34 =&gt; Double accounting$font-&gt;{Color}获取 字体颜色$font-&gt;{Strikeout}获取字体是否添加 删除线$font-&gt;{Super}获取字体是 上标 还是 下标 ，如下：1230 =&gt; 无1 =&gt; 上标2 =&gt; 下标使用方法 - 新建Excel引用 use Spreadsheet::WriteExcel; 类，如下：1use Spreadsheet::WriteExcel;workbooknew()new()方法可以基于文件名新建一个excel表，如下：1my $workbook = Spreadsheet::WriteExcel-&gt;new(&apos;filename.xls&apos;); #新建xls表若是新建2007版以上的excel，则需要用到 Excel::Writer::XLSX ，如下：12use Excel::Writer::XLSX; #引用my $workbook = Excel::Writer::XLSX-&gt;new( &apos;perl.xlsx&apos; ); #新建xlsx表若创建失败，则返回under，如下：1die &quot;Problems creating new Excel file: $!&quot; unless defined $workbook;compatibility_mode()用于增强兼容性，如下：1$workbook-&gt;compatibility_mode(); #用于增强兼容性add_worksheet($sheetname)新增一个sheet，如下：123$worksheet1 = $workbook-&gt;add_worksheet(); # Sheet1$worksheet2 = $workbook-&gt;add_worksheet(&apos;自定义名称&apos;); # 自定义名称$worksheet3 = $workbook-&gt;add_worksheet(); # Sheet3add_chart(%properties)更多详细请移步 Spreadsheet::WriteExcel::Chartclose()一般情况下，excel文件会自动关闭，但使用 close() 可以确定关闭excel文件，如下：1$workbook-&gt;close() or die &quot;Error closing file: $!&quot;; #关闭excel文件set_properties()设置excel表附加信息，如下：123456#设置excel表附加信息$workbook-&gt;set_properties( title =&gt; &apos;This is an example spreadsheet&apos;, author =&gt; &apos;John McNamara&apos;, comments =&gt; &apos;Created with Perl and Spreadsheet::WriteExcel&apos;,);可设置的信息如下：12345678titlesubjectauthormanagercompanycategorykeywordscommentsworksheetwrite($row, $column, $token, $format)12345678910111213141516$worksheet-&gt;write(0, 0, &apos;Hello&apos; ); # write_string()$worksheet-&gt;write(1, 0, &apos;One&apos; ); # write_string()$worksheet-&gt;write(2, 0, 2 ); # write_number()$worksheet-&gt;write(3, 0, 3.00001 ); # write_number()$worksheet-&gt;write(4, 0, &quot;&quot; ); # write_blank()$worksheet-&gt;write(5, 0, &apos;&apos; ); # write_blank()$worksheet-&gt;write(6, 0, undef ); # write_blank()$worksheet-&gt;write(7, 0 ); # write_blank()$worksheet-&gt;write(8, 0, &apos;http://www.perl.com/&apos;); # write_url()$worksheet-&gt;write(&apos;A9&apos;, &apos;ftp://ftp.cpan.org/&apos; ); # write_url()$worksheet-&gt;write(&apos;A10&apos;, &apos;internal:Sheet1!A1&apos; ); # write_url()$worksheet-&gt;write(&apos;A11&apos;, &apos;external:c:\foo.xls&apos; ); # write_url()$worksheet-&gt;write(&apos;A12&apos;, &apos;=A3 + 3*A4&apos; ); # write_formula()$worksheet-&gt;write(&apos;A13&apos;, &apos;=SIN(PI()/4)&apos; ); # write_formula()$worksheet-&gt;write(&apos;A14&apos;, \@array ); # write_row()$worksheet-&gt;write(&apos;A15&apos;, [\@array] ); # write_col()$format 参数是可选的，用于定义单元格的格式，如下：123456my $format = $workbook-&gt;add_format();$format-&gt;set_bold(); #加粗$format-&gt;set_color(&apos;red&apos;); #字体红色$format-&gt;set_align(&apos;center&apos;); #居中 $worksheet-&gt;write(4, 0, &apos;Hello&apos;, $format);单元格坐标的确认使用格式如下：12(0, 0)(&apos;A1&apos;)互换使用方法如下：1234use Spreadsheet::WriteExcel::Utility; ($row, $col) = xl_cell_to_rowcol(&apos;C2&apos;); # (1, 2)$str = xl_rowcol_to_cell(1, 2); # C2keep_leading_zeros()excel会将类似于数字的内容转换成数字，例如输入 0123 ，excel会将它转化为 123 ，如果想呈现出 0123 ，则做如下处理：12345678910111213# 如下，结果是 1209$worksheet-&gt;write(&apos;A1&apos;, &apos;01209&apos;); # 设置格式，结果是 01209my $format1 = $workbook-&gt;add_format(num_format =&gt; &apos;00000&apos;);$worksheet-&gt;write(&apos;A2&apos;, &apos;01209&apos;, $format1); # 使用字符串格式，结果是 01209$worksheet-&gt;write_string(&apos;A3&apos;, &apos;01209&apos;); # 使用keep_leading_zeros()方法，结果是 01209$worksheet-&gt;keep_leading_zeros();$worksheet-&gt;write(&apos;A4&apos;, &apos;01209&apos;);以上操作呈现出的效果如下：1234567 -----------------------------------------------------------| | A | B | C | D | ... -----------------------------------------------------------| 1 | 1209 | | | | ...| 2 | 01209 | | | | ...| 3 | 01209 | | | | ...| 4 | 01209 | | | | ...write_row($row, $column, $array_ref, $format)写入数组数据，如下：123456789@array = (&apos;awk&apos;, &apos;gawk&apos;, &apos;mawk&apos;);$array_ref = \@array; $worksheet-&gt;write_row(0, 0, $array_ref); # 以上代码等价于$worksheet-&gt;write(0, 0, $array[0]);$worksheet-&gt;write(0, 1, $array[1]);$worksheet-&gt;write(0, 2, $array[2]);若是二维数组，如下：1234567@eec = ( [&apos;maggie&apos;, &apos;milly&apos;, &apos;molly&apos;, &apos;may&apos; ], [13, 14, 15, 16 ], [&apos;shell&apos;, &apos;star&apos;, &apos;crab&apos;, &apos;stone&apos;] ); $worksheet-&gt;write_row(&apos;A1&apos;, \@eec);呈现出的效果，如下：123456789 -----------------------------------------------------------| | A | B | C | D | E | ... -----------------------------------------------------------| 1 | maggie | 13 | shell | ... | ... | ...| 2 | milly | 14 | star | ... | ... | ...| 3 | molly | 15 | crab | ... | ... | ...| 4 | may | 16 | stone | ... | ... | ...| 5 | ... | ... | ... | ... | ... | ...| 6 | ... | ... | ... | ... | ... | ...write_col($row, $column, $array_ref, $format)写入数组数据，如下：123456789@array = (&apos;awk&apos;, &apos;gawk&apos;, &apos;mawk&apos;);$array_ref = \@array; $worksheet-&gt;write_col(0, 0, $array_ref); # 以上代码等价于$worksheet-&gt;write(0, 0, $array[0]);$worksheet-&gt;write(1, 0, $array[1]);$worksheet-&gt;write(2, 0, $array[2]);若是二维数组，如下：1234567@eec = ( [&apos;maggie&apos;, &apos;milly&apos;, &apos;molly&apos;, &apos;may&apos; ], [13, 14, 15, 16 ], [&apos;shell&apos;, &apos;star&apos;, &apos;crab&apos;, &apos;stone&apos;] ); $worksheet-&gt;write_col(&apos;A1&apos;, \@eec);呈现出的效果，如下：123456789 -----------------------------------------------------------| | A | B | C | D | E | ... -----------------------------------------------------------| 1 | maggie | milly | molly | may | ... | ...| 2 | 13 | 14 | 15 | 16 | ... | ...| 3 | shell | star | crab | stone | ... | ...| 4 | ... | ... | ... | ... | ... | ...| 5 | ... | ... | ... | ... | ... | ...| 6 | ... | ... | ... | ... | ... | ...write_url($row, $col, $url, $label, $format)写入超链接，如下：12345$worksheet-&gt;write_url(0, 0, &apos;ftp://www.perl.org/&apos; );$worksheet-&gt;write_url(1, 0, &apos;http://www.perl.com/&apos;, &apos;Perl home&apos; );$worksheet-&gt;write_url(&apos;A3&apos;, &apos;http://www.perl.com/&apos;, $format );$worksheet-&gt;write_url(&apos;A4&apos;, &apos;http://www.perl.com/&apos;, &apos;Perl&apos;, $format);$worksheet-&gt;write_url(&apos;A5&apos;, &apos;mailto:jmcnamara@cpan.org&apos; );write_url_range($row1, $col1, $row2, $col2, $url, $string, $format)在一块区域内写入超链接，如下：1234$worksheet-&gt;write_url(0, 0, 0, 3, &apos;ftp://www.perl.org/&apos; );$worksheet-&gt;write_url(1, 0, 0, 3, &apos;http://www.perl.com/&apos;, &apos;Perl home&apos;);$worksheet-&gt;write_url(&apos;A3:D3&apos;, &apos;internal:Sheet2!A1&apos; );$worksheet-&gt;write_url(&apos;A4:D4&apos;, &apos;external:c:\temp\foo.xls&apos; );write_formula($row, $column, $formula, $format, $value)写入公式，如下：123456$worksheet-&gt;write_formula(0, 0, &apos;=$B$3 + B4&apos; );$worksheet-&gt;write_formula(1, 0, &apos;=SIN(PI()/4)&apos;);$worksheet-&gt;write_formula(2, 0, &apos;=SUM(B1:B5)&apos; );$worksheet-&gt;write_formula(&apos;A4&apos;, &apos;=IF(A3&gt;1,&quot;Yes&quot;, &quot;No&quot;)&apos; );$worksheet-&gt;write_formula(&apos;A5&apos;, &apos;=AVERAGE(1, 2, 3, 4)&apos; );$worksheet-&gt;write_formula(&apos;A6&apos;, &apos;=DATEVALUE(&quot;1-Jan-2001&quot;)&apos;);write_comment($row, $column, $string, …)增加批注，如下：12$worksheet-&gt;write (2, 2, &apos;Hello&apos;);$worksheet-&gt;write_comment(2, 2, &apos;这是个批注&apos;);还可以增加信息如下：1234567891011121314# encoding =&gt; 若为1，则表明使用UTF-16BE编码# author =&gt; 批注的作者# author_encoding =&gt; 作者字符串是否用UTF-16BE编码# visible =&gt; 是否设置开启excel时批注可见。1为可见；0为不可见# x_scale =&gt; 设置批注框宽度的压缩比# width =&gt; 设置批注框宽度# y_scale =&gt; 设置批注框高度的压缩比# height =&gt; 设置批注框高度# color =&gt; 设置批注框背景色# start_cell =&gt; 设置批注框出现的位置，如“E2”# start_row =&gt; 设置批注框出现的行位置# start_col =&gt; 设置批注框出现的列位置$worksheet-&gt;write_comment(&apos;C3&apos;, &apos;Hello&apos;, visible =&gt; 1, author =&gt; &apos;Perl&apos;);insert_image($row, $col, $filename, $x, $y, $scale_x, $scale_y)在sheet中插入一个png、jpeg或bmp格式的图片， $x 和 $y 表示在单元格中图片靠左和靠上的距离， $scale_x 和 $scale_y 表示缩放比例，如下：1$worksheet-&gt;insert_image(&apos;A1&apos;, &apos;perl.bmp&apos;, 0, 0, 2, 0.8);insert_chart($row, $col, $chart, $x, $y, $scale_x, $scale_y)插入表格，详情请移步 Spreadsheet::WriteExcel::Chartdata_validation()下拉选项，如下：1234567891011121314#仅能输入大于100的数字$worksheet-&gt;data_validation(&apos;B3&apos;, &#123; validate =&gt; &apos;integer&apos;, criteria =&gt; &apos;&gt;&apos;, value =&gt; 100, &#125;); #在下拉选项中选择值$worksheet-&gt;data_validation(&apos;B5:B9&apos;, &#123; validate =&gt; &apos;list&apos;, value =&gt; [&apos;open&apos;, &apos;high&apos;, &apos;close&apos;], &#125;);get_name()获取sheet表的名称，如下：123foreach my $sheet ($workbook-&gt;sheets()) &#123; print $sheet-&gt;get_name();&#125;activate()设置默认展示的sheet表，如下：12345$worksheet1 = $workbook-&gt;add_worksheet(&apos;To&apos;);$worksheet2 = $workbook-&gt;add_worksheet(&apos;the&apos;);$worksheet3 = $workbook-&gt;add_worksheet(&apos;wind&apos;); $worksheet3-&gt;activate(); #默认展示wind表select()选中sheet表，如下：123$worksheet1-&gt;activate();$worksheet2-&gt;select();$worksheet3-&gt;select();hide()隐藏sheet表，如下：1$worksheet2-&gt;hide();set_first_sheet()设置为第一个sheet，如下：123456789for (1..20) &#123; $workbook-&gt;add_worksheet;&#125; $worksheet21 = $workbook-&gt;add_worksheet();$worksheet22 = $workbook-&gt;add_worksheet(); $worksheet21-&gt;set_first_sheet(); #设置为第一个sheet$worksheet22-&gt;activate();protect($password)开启保护，密码可选，如下：123$worksheet-&gt;protect();or$worksheet-&gt;protect(&apos;drowssap&apos;);set_selection($first_row, $first_col, $last_row, $last_col)选中指定区域，如下：123456$worksheet1-&gt;set_selection(3, 3); # 1. Cell D4.$worksheet2-&gt;set_selection(3, 3, 6, 6); # 2. Cells D4 to G7.$worksheet3-&gt;set_selection(6, 6, 3, 3); # 3. Cells G7 to D4.$worksheet4-&gt;set_selection(&apos;D4&apos;); # Same as 1.$worksheet5-&gt;set_selection(&apos;D4:G7&apos;); # Same as 2.$worksheet6-&gt;set_selection(&apos;G7:D4&apos;); # Same as 3.set_row($row, $height, $format, $hidden, $level, $collapsed)设置行属性，如下：1$worksheet-&gt;set_row(0, 20); # 设置第一行的行高为20set_column($first_col, $last_col, $width, $format, $hidden, $level, $collapsed)设置列属性，同上merge_range($first_row, $first_col, $last_row, $last_col, $token, $format, $utf_16_be)合并单元格，如下：1234567my $format = $workbook-&gt;add_format( border =&gt; 6, valign =&gt; &apos;vcenter&apos;, align =&gt; &apos;center&apos;, ); $worksheet-&gt;merge_range(&apos;B3:D4&apos;, &apos;Vertical and horizontal&apos;, $format);set_zoom($scale)设置zoom属性right_to_left()颠倒A1的位置hide_zero()隐藏为0的值，如下：1$worksheet-&gt;hide_zero();set_tab_color()设置sheet Tab的颜色，如下：12$worksheet1-&gt;set_tab_color(&apos;red&apos;);$worksheet2-&gt;set_tab_color(0x0C);autofilter($first_row, $first_col, $last_row, $last_col)自动筛选，如下：12$worksheet-&gt;autofilter(0, 0, 10, 3);$worksheet-&gt;autofilter(&apos;A1:D11&apos;); # Same as above in A1 notation.filter_column($column, $expression)设置筛选条件，如下：12$worksheet-&gt;filter_column(&apos;A&apos;, &apos;x &gt; 2000&apos;);$worksheet-&gt;filter_column(&apos;B&apos;, &apos;x &gt; 2000 and x &lt; 5000&apos;);运算符如下：12345678910运算符 近义词 == = eq =~ != &lt;&gt; ne != &gt; &lt; &gt;= &lt;= and &amp;&amp; or ||* 表示一个或多个字符， ？ 表示一个字符123456789101112&apos;x == Blanks&apos; #空白&apos;x == NonBlanks&apos; #不为空白&apos;Top 10 Items&apos; #前10个&apos;Bottom 5 Items&apos; #后5个&apos;Top 25 %&apos; #前25%&apos;Bottom 50 %&apos; #后50%&apos;x =~ b*&apos; # 以b开头&apos;x !~ b*&apos; # 不以b开头&apos;x =~ *b&apos; # 以b结尾&apos;x !~ *b&apos; # 不以b结尾&apos;x =~ *b*&apos; # 包含b&apos;x !~ *b*&apos; # 不包含bformatset_format_properties(%properties)设置单元格属性，如下：12my $format = $workbook-&gt;add_format();$format-&gt;set_format_properties(bold =&gt; 1, color =&gt; &apos;red&apos;);set_font($fontname)设置字体，默认为 Arial ，如下：1$format-&gt;set_font(&apos;Times New Roman&apos;);set_size()设置字体大小，默认大小为 10 ,如下：12my $format = $workbook-&gt;add_format();$format-&gt;set_size(30);set_color()设置字体颜色，如下：1234567891011121314151617181920# &apos;black&apos;# &apos;blue&apos;# &apos;brown&apos;# &apos;cyan&apos;# &apos;gray&apos;# &apos;green&apos;# &apos;lime&apos;# &apos;magenta&apos;# &apos;navy&apos;# &apos;orange&apos;# &apos;pink&apos;# &apos;purple&apos;# &apos;red&apos;# &apos;silver&apos;# &apos;white&apos;# &apos;yellow&apos;my $format = $workbook-&gt;add_format();$format-&gt;set_color(&apos;red&apos;);$worksheet-&gt;write(0, 0, &apos;wheelbarrow&apos;, $format);set_bold()是否开启加粗。一般情况下可以添加100-1000的参数。400表示正常，700表示加粗，1000表示非常粗。但最好是不写，如下：1$format-&gt;set_bold(); #加粗set_italic()设置斜体，如下：1$format-&gt;set_italic();set_underline()设置下划线，如下：1234$format-&gt;set_underline(0); #取消下划线$format-&gt;set_underline(); #设置下划线$format-&gt;set_underline(1); #设置下划线$format-&gt;set_underline(2); #设置双下划线set_font_strikeout()设置删除线set_font_script()设置角标，如下：1230 =&gt; 正常1 =&gt; 上角标2 =&gt; 下角标set_num_format()设置数字格式，如下：123456789101112131415161718192021222324252627282930313233343536373839$format01-&gt;set_num_format(&apos;0.000&apos;);$worksheet-&gt;write(0, 0, 3.1415926, $format01); # 3.142 $format02-&gt;set_num_format(&apos;#,##0&apos;);$worksheet-&gt;write(1, 0, 1234.56, $format02); # 1,235 $format03-&gt;set_num_format(&apos;#,##0.00&apos;);$worksheet-&gt;write(2, 0, 1234.56, $format03); # 1,234.56 $format04-&gt;set_num_format(&apos;$0.00&apos;);$worksheet-&gt;write(3, 0, 49.99, $format04); # $49.99 # Note you can use other currency symbols such as the pound or yen as well.# Other currencies may require the use of Unicode. $format07-&gt;set_num_format(&apos;mm/dd/yy&apos;);$worksheet-&gt;write(6, 0, 36892.521, $format07); # 01/01/01 $format08-&gt;set_num_format(&apos;mmm d yyyy&apos;);$worksheet-&gt;write(7, 0, 36892.521, $format08); # Jan 1 2001 $format09-&gt;set_num_format(&apos;d mmmm yyyy&apos;);$worksheet-&gt;write(8, 0, 36892.521, $format09); # 1 January 2001 $format10-&gt;set_num_format(&apos;dd/mm/yyyy hh:mm AM/PM&apos;);$worksheet-&gt;write(9, 0, 36892.521, $format10); # 01/01/2001 12:30 AM $format11-&gt;set_num_format(&apos;0 &quot;dollar and&quot; .00 &quot;cents&quot;&apos;);$worksheet-&gt;write(10, 0, 1.87, $format11); # 1 dollar and .87 cents # Conditional formatting$format12-&gt;set_num_format(&apos;[Green]General;[Red]-General;General&apos;);$worksheet-&gt;write(11, 0, 123, $format12); # &gt; 0 Green$worksheet-&gt;write(12, 0, -45, $format12); # &lt; 0 Red$worksheet-&gt;write(13, 0, 0, $format12); # = 0 Default colour # Zip code$format13-&gt;set_num_format(&apos;00000&apos;);$worksheet-&gt;write(14, 0, &apos;01209&apos;, $format13);set_locked()是否上锁，如下：1234567891011121314my $locked = $workbook-&gt;add_format();$locked-&gt;set_locked(1); # A non-op my $unlocked = $workbook-&gt;add_format();$locked-&gt;set_locked(0); # Enable worksheet protection$worksheet-&gt;protect(); # This cell cannot be edited.$worksheet-&gt;write(&apos;A1&apos;, &apos;=1+2&apos;, $locked); # This cell can be edited.$worksheet-&gt;write(&apos;A2&apos;, &apos;=1+2&apos;, $unlocked);set_hidden()是否隐藏，如下：12345678my $hidden = $workbook-&gt;add_format();$hidden-&gt;set_hidden(); # Enable worksheet protection$worksheet-&gt;protect(); # The formula in this cell isn&apos;t visible$worksheet-&gt;write(&apos;A1&apos;, &apos;=1+2&apos;, $hidden);set_align()设置对齐方式，如下：12345678910111213Horizontal# &apos;left&apos; # &apos;center&apos;# &apos;right&apos;# &apos;fill&apos;# &apos;justify&apos;# &apos;center_across&apos;Vertical# &apos;top&apos;# &apos;vcenter&apos;# &apos;bottom&apos;# &apos;vjustify&apos;set_bg_color()设置背景色set_fg_color()设置前景色set_border()设置边框，如下：12345678910111213141516Index Name Weight Style===== ============= ====== ===========0 None 01 Continuous 1 -----------2 Continuous 2 -----------3 Dash 1 - - - - - -4 Dot 1 . . . . . .5 Continuous 3 -----------6 Double 3 ===========7 Continuous 0 -----------8 Dash 2 - - - - - -9 Dash Dot 1 - . - . - .10 Dash Dot 2 - . - . - .11 Dash Dot Dot 1 - . . - . .12 Dash Dot Dot 2 - . . - . .13 SlantDash Dot 2 / - . / - .set_border_color()设置边框颜色copy($format)格式刷更多详情请移步 Spreadsheet::WriteExcel 的官方资料]]></content>
      <categories>
        <category>Perl</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT在线课堂有哪些]]></title>
    <url>%2FIT%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[想当初，我还在读大二时候就对安卓编程特别感兴趣。可惜了，学校没这门课，而我又是生物技术专业的人，更是没有良师益友可以拜访，于是只能奔走于各大图书馆。现在可好了，网上各种视频教学网站百花齐放，于是整理一下我常用的视频教学网站，供大家参考。慕课网慕课网（IMOOC）是IT技能学习平台。可谓是程序猿的梦工厂，涵盖所有IT相关的教程视频，我的很多门编程语言启蒙老师都是它。免费视频的质量很不错，至于收费视频的质量嘛，我没用过，就不置可否了。。。极客学院极客学院 Wiki 为中国最大 IT 职业在线教育平台极客学院旗下图文开发技术教程站点，拥有海量 IT 图文教程，涵盖 30+ 个技术领域，如 Android, iOS, Java, Python, HTML5, Swift, Cocos2dx, Apple Watch 等图文教程。网易云课堂网易云课堂，一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作，聚合了丰富的学习内容，包括课程、电子书、文章、短视频、音频等。51CTO学院51CTO学院涵盖Python、大数据、区块链、IT考证等培训领域，随到随学、通关学习、一对一辅导。腾讯课堂腾讯课堂-腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师，下设职业培训、公务员考试、托福雅思、考证考级、英语口语、中小学教育等众多在线学习精品课程，打造老师在线上课教学、学生及时互动学习的课堂。汇智网汇智网是一个学习最前沿编程技术的平台，提供了mongodb，node.js，javascript，jquery等相关的课程。互动式的学习和实时在线的练习，能让你迅速进入状态，快速完成课程学习。HTML中文网html中文网是一个专业的web前端开发在线学习、培训、交流平台。大量精品前端学习图文、视频教程及下载资源，可边学习边编程实战，快速成为前端工程师。Swift课堂SwiftV课堂是国内氛围最好的swift学习、交流网站，提供上千套swift视频，swift教程免费观看。]]></content>
      <categories>
        <category>导航</category>
      </categories>
      <tags>
        <tag>IT在线课堂</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac打包dmg文件(更换背景图)]]></title>
    <url>%2FMac%E6%89%93%E5%8C%85dmg%E6%96%87%E4%BB%B6(%E6%9B%B4%E6%8D%A2%E8%83%8C%E6%99%AF%E5%9B%BE)%2F</url>
    <content type="text"><![CDATA[效果-1.png)准备事前准备好一张背景图片和应用程序app，如下图：-2.png)获取 应用程序 文件夹的替身，如下：打开 达访窗口 -&gt; 右键 应用程序 -&gt; 在上层文件夹中显示-3.png)新窗口中 -&gt; 右键点击 应用程序 文件夹 -&gt; 制作替身-4.png)制作打开 磁盘工具 -&gt; 文件 -&gt; 新建磁盘 -&gt; 空白映像 ，如下图：-5.png)配置信息：存储为：任意文件名均可，可和文件夹同名名称：建议设置为软件安装包的名称，这将是软件安装卷的名字大小容量：不低于所有需打包文件的容量之和分区：有的教程说要选择：CD/DVD，这里不要修改默认设置。我试过了，如果修改成 CD/DVD 则最多只能制作500M大小的dmg文件-6.png)右键点击 磁盘工具 中 新建的磁盘映像 ，点击 在达访中显示 ，此时出现空白窗口，将需打包的所有文件拖进去，并摆放整齐，如下：-7.png)-8.png)窗口空白处右键 查看显示选项 ，将窗口中的背景图片拖到箭头所指的框内，如下图：-9.png)隐藏背景图片，输入如下代码：1chflags hidden /Volumes/未命名/bg-2.png注意：未命名 换成步骤2中创建空白映像时自定义的 名称注意：bg-2.png换成背景图片的 文件名.后缀注意：显示图片的代码为:1chflags nohidden /Volumes/未命名/bg-2.png调整窗口大小，如下图：-1.png)磁盘工具 -&gt; 映像 -&gt; 转换注意：转换前，务必将桌面上的磁盘映像弹出，否则会转换失败-10.png)配置转换信息，可以选择 加密 ，如下：-11.png)完成。ps：制作网址快捷方式打开Safari浏览器 -&gt; 打开你的网址 -&gt; 点击地址栏 -&gt; 在网址前会出现一个网站图标 -&gt; 拖动图标到桌面上，你的网址快捷位置按钮就生成了。]]></content>
      <categories>
        <category>IT实用技能</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>dmg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT技术社区有哪些]]></title>
    <url>%2FIT%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[技术社区一般有三类人：第一类是善于检索答案的人，即遇到问题时在社区寻找答案，绝大部分初级程序员都是通过这种方式来了解技术社区的；第二类是善于学习技术的人，即有意识的常去技术社区查看博客，学习新知识；第三类是善于解决问题的人，喜欢分享某一类技术，或者他们的实战经历。往往写文章的人，也喜欢看文章。中文社区CSDNCSDN是一个专业的IT技术社区，致力于为中国软件开发者提供知识传播、在线学习、职业发展等全生命周期服务。开源中国开源中国是目前中国最大的开源技术社区。我们传播开源的理念，推广开源项目，为 IT 开发者提供了一个发现、使用、并交流开源技术的平台。目前开源中国社区已收录近五万款开源软件。掘金掘金是一个帮助开发者成长的社区，技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货，其中包括：Android、iOS、前端、后端等方面的内容。简书简书是一个优质的创作社区，在这里，你可以任性地创作，一篇短文、一张照片、一首诗、一幅画……我们相信，每个人都是生活中的艺术家，有着无穷的创造力。思否SegmentFault 思否 为开发者提供问答、学习与交流编程知识的平台，创造属于开发者的时代！知乎有问题，上知乎。知乎，可信赖的问答社区，以让每个人高效获得可信赖的解答为使命。用户通过问答等交流方式建立信任和连接，打造和提升个人影响力，并发现、获得新机会。V2EXV2EX = way to explore 是创意工作者们的社区。这里目前汇聚了超过 250,000 名主要来自互联网行业、游戏行业和媒体行业的创意工作者。V2EX 希望能够成为创意工作者们的生活和事业的一部分。51CTO中国领先的IT技术网站51CTO主要为IT技术人员提供新闻资讯、技术文档、BBS、博客、技术圈、培训课程、人才交流等专业服务。ITPUB技术论坛ITPUB技术论坛专门立足讨论数据库、ERP、技术开发、操作系统、网络等方面的技术问题。博客园博客园是一个面向开发者的知识分享社区。一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。威锋网威锋网是较早建立的关于iPhone专题网站，威锋网论坛一直是人气中文iPhone、iPad、MAC社区。目前网站提供iPhone软件评测、音乐、电影、铃声下载等服务。ChinaUnixChinaUnix.net提供交流程序开发、数据库、存储备份、服务器技术、网络安全等技术，并提供IT人才招聘、软件下载、BLOG、IT培训等服务。英文社区stackoverflow全球最受程序员欢迎的IT技术问答社区，没有之一。RedditReddit是个社交新闻站点，口号：提前于新闻发生，来自互联网的声音。是一个提供兴趣讨论社区、编程开发问题和热点资讯的平台。Hacker NewsHacker News是一个提供专业技术分享的社区，包括文章、图像视频等。页面极其简单，没有广告。DZoneDZone是一个创办早、用户多的IT新闻和编程资源的分享社区。]]></content>
      <categories>
        <category>导航</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>IT社区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装软件提示“已损坏，打不开”的解决方法]]></title>
    <url>%2FMac%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E2%80%9C%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E6%89%93%E4%B8%8D%E5%BC%80%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[如图所示：或解决办法：依次打开【系统偏好设置】-&gt;【安全性与隐私】-&gt;【通用】，在【允许从以下位置下载的应用】中选择【任何来源】即可，如下图：ps：如果是新版系统，默认情况下是不允许自己下载安装应用软件的，因此没有【任何来源】选项，如下图：解决办法如下：打开终端，输入 sudo spctl --master-disable ，如下：输入用户密码，如下：即可选择【任何来源】，如下：]]></content>
      <categories>
        <category>IT实用技能</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国版权保护中心注册不了的解决办法]]></title>
    <url>%2F%E4%B8%AD%E5%9B%BD%E7%89%88%E6%9D%83%E4%BF%9D%E6%8A%A4%E4%B8%AD%E5%BF%83%E6%B3%A8%E5%86%8C%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大家应该知道，个人开发者要想上线自己的软件到第三方APP平台，多半是需要软件著作权的。因此，我今天打算注册账号、申请软著。于是有了这篇博客…按常规步骤，登录 中国版权保护中心官网 ，填写注册信息，点击 同意...，提交... 按钮，如下图：我仿如一个智障似的等了几秒钟，什么都没发生！于是猜测这种“官方网站”又犯了惯有的毛病，那就是向下兼容IE9，8，7，6，5…，却很遗憾的不支持新世纪的浏览器。遂在官网的常见问题中找寻答案，果不其然，见下图：于是，我又在 ParallelsDesktop虚拟机 上的win 7系统中找到自带的IE8浏览器，寄希望能顺利解决。但可惜了，问题依旧存在。没得法，打开页面源代码，找八哥了。如下图，我傻了，这么多报错信息。。。这可是我们国家的版权保护中心官网啊：于是，开始找bug。报错信息太多了，清空。按步骤一步步操作，一步步看报错信息。在 提交 这一步提示 找不到变量 g_emailOk ，如下图：猜测，找不到判断邮箱格式正确性的变量，于是在 console 里敲入 g_emailOk = true 回车。OK，注册成功！如下图：至此，问题解决。但是不找到原因我睡不着，接着来。在源代码中检索变量 g_emailOk，找到 提交 按钮的部分代码，如下：上面就是点击 提交 按钮报错了，但是没有给予任何提示信息的核心代码。 if 后面没有 else 代码，所以网站呈现出来的效果就是“要么成功，要么无解”。哎，这个用户体验，我是服气的 - -！接着来，定位到 输入邮箱 的代码片段，如下图：在核查邮箱格式之前，代码需要运行一个函数 inputOnfocus() 。找了一下，没有找到这个函数。回到最初的报错信息，可以找到原因。那就是缺少 register.js 文件，函数 inputOnfocus() 就在 register.js 文件里。如下图：到这里，我的问题圆满解决了。但是，这个网站留下的bug问题、映射出相关部门的问题，还没有解决，我表示力不从心…哎 - -！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Bug</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown从入门到精通]]></title>
    <url>%2FMarkdown%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[标题主标题:【语法】1主标题文字 (空行) ==（两个及以上）【示例】12主标题文字（最高阶标题）==主标题文字（最高阶标题）【说明】相当于H1大纲标题效果，一般在首行应用和表示副标题：【语法】1副标题文字 (空行) --(减号两个及以上)【示例】12主标题文字（第二阶标题）--主标题文字（第二阶标题）【说明】相当于H2大纲标题效果H1~H6大纲标题:【语法】1# (空格)文字1-6等级分别在文字前加对应数量#，后面的#为可选，不加效果也一样。【示例】12345678910111213# 大纲标题文字 H1（等同 主标题）## 大纲标题文字 H2（等同 副标题）### 大纲标题文字 H3#### 大纲标题文字 H4##### 大纲标题文字 H5###### 大纲标题文字 H6####### 大纲标题文字 H7（最多6阶）大纲标题文字 H1（等同 主标题）大纲标题文字 H2（等同 副标题）大纲标题文字 H3大纲标题文字 H4大纲标题文字 H5大纲标题文字 H6####### 大纲标题文字 H7（最多6阶）【说明】最多6个等级的大纲标题，后面加上同等数量“（空格）#”效果也一样标签【语法】1TAGS：内容 或 标签： 内容在编辑区任意行的列首位置输入tags/标签：关键词1 关键词2 ， 多个用空格隔开。【示例】1标签：教程 Markdown标签：教程 Markdown目录（大纲）导航【语法】1在段落中填写 [TOC] （toc小写也可以）以显示各标题为结构的目录（大纲）导航。强调或突出斜体：【语法】1_斜体_ 或 *斜体* 在文字两边加 单下底线 或 单星号【示例】1_斜体_ 或 *斜体*_斜体_ 或 斜体粗体：【语法】1__粗体__ 或 **粗体** 在文字两边加 双下底线 或 双星号【示例】1__粗体__ 或 **粗体**粗体 或 粗体删除线：【语法】1~~删除线~~ 在文字两边加 双波浪号【示例】1这是带有 ~~删除线~~ 的文字这是带有 删除线 的文字【说明】快速记忆：单斜双粗两波删下划线：【语法】1在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）【示例】1234这是下划线---你看到了吗？这是下划线你看到了吗？段落与分割普通段落：【语法】1用空行分隔，连着多个空行也是一个效果，只能空一行的间距。【示例】123456这是首行文字这是尾行文字，实际中间我空了2行，但还是只显示空了一行的效果。【说明】有的语法要用到空行才有效果（如主标题，列表），不空行的话默认又是会跟随上面语法特征（如表格语法前面就要空行后才有效果），应用时多加注意。这是首行文字这是尾行文字，实际中间我空了2行，但还是只显示空了一行的效果。【说明】有的语法要用到空行才有效果（如主标题，列表），不空行的话默认又是会跟随上面语法特征（如表格语法前面就要空行后才有效果），应用时多加注意。水平分割线：【语法】13个及以上的 星号***或 减号---或 下底线___来表示。【示例】1***【说明】建议只固定选用一个，如三个星号***为标准，用减号—容易和副标题搞混。强制换行：【语法】1在行尾输入两个空格【示例】123这句话(空格)(空格)会(空格)(空格)换行这句话会换行【说明】强制换行比输入回车换行的行间距小很多链接网页链接（内联风格）：【语法】1[链接文字](http://链接地址)&quot;（空格）鼠标悬停显示文字（可选）&quot;“（空格）鼠标悬停显示文字”非必须项，在pc浏览器中能看到效果，手机移动端因无鼠标效果无法直接体现。【示例】1这是去往[本人博客](https://pangao1990.github.io)的链接。这是去往本人博客的链接。链接的快速定义：【语法】1234567前面文档中引用链接的语法为：[链接文字][id]前后id要匹配一致，一般为数字，这样可以在文档的其他任意地方快速插入这个链接。后面定义链接的语法为：[id]:（空格）http://链接地址（空格）&quot;鼠标悬停显示文字（可选）&quot;后面的语法必须在列首并单独一行，适合前期不知道网址，后面再加入的情况。【示例】123这是去往[本人博客][1]的链接。[1]: https://pangao1990.github.io这是去往本人博客的链接。链接的自动展示：直接输入链接地址，可以直接识别。https://pangao1990.github.ioEmail 链接：【语法】1直接&lt;邮箱号地址&gt;即可【示例】1我的email地址是：&lt;pangao1990@qq.com&gt;。我的email地址是：&#x70;&#x61;&#110;&#103;&#97;&#x6f;&#x31;&#57;&#x39;&#x30;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;。列表有序列表：【语法】1直接数字加英文句点加空格（最多三个空格）和文字【示例】有序单层列表123520. 列表项1（第一项数字一定要为“520”）201314. 列表项2（其实我前面的标的数字是“201314”）20161130. 列表项3（其实我前面的标的数字是“20161130”列表项1（第一项数字一定要为“520”）列表项2（其实我前面的标的数字是“201314”）列表项3（其实我前面的标的数字是“20161130”【说明】后面的不必在意数字从小到大的排序，显示时会自动排序，有智能的乱序纠正功能，非常贴心。数字前面加了空格，排序会变成罗马数字形式。无序列表:【语法】1文字前面加 星号空格*（空格）或 短横空格-（空格）或 加号+（空格）表示【示例】无序单层列表12- 列表项1- 列表项2列表项1列表项2多重列表:【语法】1单层列表项缩进1个tab就可以往后面叠加子层的列表【示例】12345678910111. 首层列表项（有序）2. 第二层列表项1(嵌套的列表可以是有序的 )2. 第二层列表项2(格式和正常的有序、无序列表没有差异)3. 第三层列表项(tab)1. 三层的子列表项1(tab)2. 三层的子列表项2- 首层列表项第四层列表项2（无序）- 嵌套的列表可以是无序的(tab)- 子列表项 1（加了1个tab缩进）(tab)(tab)- 子列表项 2（加了2个tab缩进）(tab)(tab)(tab)- 子列表项 4（加了3个tab缩进）首层列表项（有序）第二层列表项1(嵌套的列表可以是有序的 )第二层列表项2(格式和正常的有序、无序列表没有差异)第三层列表项三层的子列表项1三层的子列表项2首层列表项第四层列表项2（无序）嵌套的列表可以是无序的子列表项 1（加了1个tab缩进）子列表项 2（加了2个tab缩进）子列表项 4（加了3个tab缩进）引用文字引用：【语法】1段落前面添加大于号和空格&gt; （空格），就能够形成引用段落。【示例】123&gt;(空格)青松(空格)(空格)大雪压青松，青松挺且直。(空格)(空格)要知松高洁，待到雪化时。青松大雪压青松，青松挺且直。要知松高洁，待到雪化时。添加影像附件插入图片:【语法】1![图片描述](图片网络/本地图片地址)（空格）“鼠标悬停显示文字（可选）”【说明】和网页链接用法一致。代码块行内（内联）代码【语法】12使用`内容` 表示行内 代码块。即 在文字左右使用反引号包含（键盘数字“1”前面的波浪号大写状态时能打出）。【示例】1我是一只`小鸭子`，咿呀咿呀哟。我是一只小鸭子，咿呀咿呀哟。【说明】和标签/关键词的效果差不多，还可用于如按键Ctrl+F4，字母B，单词F**K、短句Are you ok？等诸多行的应用场景。能起到强调区分的作用。段落文本代码块:【语法】1每行缩进4个空格或 1个 Tab表示【示例】1(tab)这是一个代码块。这是一个代码块。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序云开发的云函数中自增函数inc报错]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E7%9A%84%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%AD%E8%87%AA%E5%A2%9E%E5%87%BD%E6%95%B0inc%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[错误提示 message _ is not defined 如下：其实吧， -404011 和 -504002 这些错误提示都基本没用。主要看我画红线的地方，说不认得 _ 。再回过头好好看看官方文档，原来是掉了一条定义 _ 的代码，如下：如果你也和我一样粗心，希望本文能帮到你。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中的云开发如何检测云函数中的对象是否存在某个属性]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%91%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[常规的 JS检测对象中是否存在某个属性 的方法不管用，可能微信云函数屏蔽了一些功能。试来试去，找到一个办法，如果有更优雅的办法，欢迎来喷。使用 捕获异常 的办法，如下：判断 reult 中是否含有 data 这个键12345678try &#123; var data = reult.data //有&#125; catch (e) &#123; //没有&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中的云开发如何使用云函数生成二维码]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%91%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%91%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[首先，需要给对应的云函数安装 request-promise 依赖。（不会给云函数安装依赖的盆友请移步 微信小程序中的云开发如何使用npm安装依赖）生成二维码的云函数如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 云函数入口文件const cloud = require('wx-server-sdk')const rp = require('request-promise')cloud.init()// 云函数入口函数exports.main = async (event, context) =&gt; &#123; const page = event.page const scene = event.scene //appid和秘钥 const appid = '***', secret = '***'; const AccessToken_options = &#123; method: 'GET', url: 'https://api.weixin.qq.com/cgi-bin/token', qs: &#123; appid, secret, grant_type: 'client_credential' &#125;, json: true &#125;; //获取AccessToken const resultValue = await rp(AccessToken_options); const token = resultValue.access_token; //获取小程序码配置 const code_options = &#123; method: 'POST', url: 'https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=' + token, body: &#123; 'page': page, 'width': 430, 'scene': scene &#125;, json: true, encoding: null &#125;; //获取二进制图片 const buffer = await rp(code_options); const upload = await cloud.uploadFile(&#123; cloudPath: 'wxacode.png', fileContent: buffer, &#125;) return &#123; wxacodefileID: upload.fileID &#125;&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中的云开发如何使用npm安装依赖]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%91%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8npm%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[微信小程序开发教程描述的相当模糊，以至于我反复品读，多次尝试才悟出来该怎么在云开发中使用 npm 安装依赖。首先强调一下，云开发中必须安装 wx-server-sdk 依赖， 而wx-server-sdk 依赖需要使用 npm 的。但由于部分开发过程可能不再需要其他的依赖，那么每次开发都要使用 npm 安装依赖是一件很麻烦的事情。微信为了简化云开发操作，提供了一键云端安装 wx-server-sdk 依赖，也就是在云端帮助我们搞定，不需要我们手动在本地使用 npm 安装，如下图：如果某个自建的云函数需要使用 npm 安装第三方依赖，该怎么办呢？操作如下：1. 右键云函数，选择“终端打开”，如下图：2. 安装所需依赖：1npm install request-promise --production3. 紧接着，千万别忘了，安装 wx-server-sdk 依赖：1npm install wx-server-sdk --production4. 选择“上传并部署：所有文件”，如下图：5. 等待完成，即可，如下图：ps:若不使用npm，则直接选择“云端安装依赖”。若要使用npm，则需在终端中手动安装依赖。此时，千万不要忘记安装 wx-server-sdk 依赖，因为“上传并部署：所有文件”这一选项并不会帮我们傻瓜式安装 wx-server-sdk 依赖。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之新增看板娘(能说话、能换装)]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%96%B0%E5%A2%9E%E7%9C%8B%E6%9D%BF%E5%A8%98(%E8%83%BD%E8%AF%B4%E8%AF%9D%E3%80%81%E8%83%BD%E6%8D%A2%E8%A3%85)%2F</url>
    <content type="text"><![CDATA[效果图：教程：小白水平：hexo的官方是支持看板娘的，已经封装好了插件，但只是模型，不能说话、不能换装、功能较少。安装模块，如下：1npm install --save hexo-helper-live2d在 站点配置文件 或 主题配置文件 中新增如下内容：12345678910111213141516171819202122232425# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right width: 150 height: 300 mobile: show: true # 手机中是否展示小白水平，效果如下：大神水平：大神作品，功能齐全。能说话、能换装、能玩游戏、能拍照、还能自定义。下载 张书樵大神的项目，解压到本地博客目录的 themes/next/source 下，修改文件夹名为 live2d-widget，修改项目中的 autoload.js 文件，如下：将1const live2d_path = "https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/";改为1const live2d_path = "/live2d-widget/";在/themes/next/layout/_layout.swig中,新增如下内容：1&lt;script src="/live2d-widget/autoload.js"&gt;&lt;/script&gt;在 主题配置文件 中,新增如下内容：12live2d: enable: true想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 和 waifu.css。大神水平，效果如下：后记注意：大神的项目需要 jQuery 和 font-awesome 支持。我的项目因为其他插件需要，所以在很早之前就下载这两个文件到本地关联了，因此不需要再重复添加。若是没有添加依赖的小伙伴，可以在页面中加载。例如在 &lt;head&gt; 中加入：12&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt;或是像我一样，将这两个文件下载到本地，再关联。因为最近工作比较忙，没有时间更新博客。由于我的疏忽，漏掉了后记中比较关键的文件依赖和大神项目文件夹的重命名，导致很多小伙伴无法实现大神项目的效果。我感到非常抱歉，同时，非常感谢留言的大神们对本博客的批评指正，后期我会提升博客质量和更新频率。再次感谢！]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之文末统一添加“本文结束”标记]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%96%87%E6%9C%AB%E7%BB%9F%E4%B8%80%E6%B7%BB%E5%8A%A0%E2%80%9C%E6%9C%AC%E6%96%87%E7%BB%93%E6%9D%9F%E2%80%9D%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[效果图：教程：在目录 themes/next/layout/_macro/ 下添加 passage-end-tag.swig ，内容如下：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;打开 themes/next/layout/_macro/post.swig 文件，新增内容如下:12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt;打开主题配置文件 ，添加代码如下：123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之自定义文章底部版权声明]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[效果图：教程：在目录 themes/next/layout/_macro/ 下添加 my-copyright.swig ，内容如下：123456789101112131415161718192021222324252627282930313233&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125;在目录 themes/next/source/css/_common/components/post/ 下添加 my-post-copyright.styl，内容如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #333333; // title color font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #0593d3; // link color text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125;修改 themes/next/layout/_macro/post.swig ，如下：在代码12345&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include 'wechat-subscriber.swig' %&#125; &lt;/div&gt;&#123;% endif %&#125;之前，新增如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;打开 themes/next/source/css/_common/components/post/post.styl 文件，在最后一行增加代码：1@import "my-post-copyright"设置新建文章自动开启 copyright ，即新建文章自动显示自定义的版权声明，设置 ～/scaffolds/post.md 文件，如下：12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;copyright: true #新增,开启---]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之显示当前浏览进度]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%B5%8F%E8%A7%88%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[效果图：教程：打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true ，如下：12# Scroll percent label in b2t button scrollpercent: true如果想把 top 按钮放在侧边栏,打开 themes/next/_config.yml ,搜索关键字 b2t ,把 false 改为 true ，如下：12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之评论系统]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[效果图：Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。教程：登录 Leancloud 官网，注册之后创建一个应用，选择【设置】-&gt;【应用Key】记下你的APP ID和APP Key，如下：编辑 主题配置文件，搜索 Valine，填入appid 和 appkey，如下：123456789101112valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your app id appkey: # your app key notify: true # 评论回复邮件提醒, See: https://github.com/xCss/Valine/wiki verify: false # 验证码服务 placeholder: 留言区 # 评论框占位提示符 avatar: mm # 头像配置 guest_info: nick,mail,link # 回复要填写的信息 pageSize: 10 # 评论列表分页，每页条数 visitor: false # 文章访问量统计 comment_count: true # if false, comment count will only be displayed in post page, not in home page可选操作： 在【Leancloud】 -&gt; 【设置】 -&gt; 【安全中心】 -&gt; 【Web 安全域名】把你的域名加进去，可防止数据被篡改。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之搜索服务]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[效果图：教程：安装插件hexo-generator-searchdb，如下：1npm install hexo-generator-searchdb --save编辑 站点配置文件，新增以下内容到任意位置，如下：12345search: path: search.xml field: post format: html limit: 10000编辑 主题配置文件，启用本地搜索功能，如下：123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AdobePhotoshopCC2019-图形处理中文完美Mac版]]></title>
    <url>%2FAdobePhotoshopCC2019-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87%E5%AE%8C%E7%BE%8EMac%E7%89%88%2F</url>
    <content type="text"><![CDATA[简介：Adobe Photoshop CC 2019是数字图像处理和编辑的行业标准，提供了一整套专业的修饰工具，并拥有强大的编辑功能，旨在激发灵感。教程：压缩包内含详细教程。下载地址：云盘下载密码: tpgxdmg打开密码: blog.pangao.vip本软件来源于网络，仅供学习使用，请在24小时内删除，本人不承担任何相关责任！若侵犯某些组织或个人的权益，请联系我删除。]]></content>
      <categories>
        <category>Mac软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageOptim-无损图片压缩Mac版]]></title>
    <url>%2FImageOptim-%E6%97%A0%E6%8D%9F%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9Mac%E7%89%88%2F</url>
    <content type="text"><![CDATA[简介：ImageOptim 是一款小巧免费且开源的 Mac 图片无损压缩优化工具。默认设置下，它的压缩号称是「无损」的，也就是说画质不会被改变，但体积却可以被减小，堪称神器！教程ImageOptim 支持 PNG、JPG、GIF 格式的图片压缩优化，你只需将文件拖放到它的界面上即可完成优化 (PS：处理后会覆盖原图 / 原图被移到垃圾桶，可手工恢复)，支持批量，使用上非常简单方便。效果比对：下载地址：官方下载]]></content>
      <categories>
        <category>Mac软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用PS修改GIF动图循环播放次数]]></title>
    <url>%2F%E7%94%A8PS%E4%BF%AE%E6%94%B9GIF%E5%8A%A8%E5%9B%BE%E5%BE%AA%E7%8E%AF%E6%92%AD%E6%94%BE%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[用Photoshop（Mac中文完美版下载地址）修改GIF动图循环播放次数，一次、三次、无限次循环播放…其实很容易。教程用Photoshop打开GIF动图，选择【文件】-&gt;【导出】-&gt;【存储为Web所用格式】，如下：动画循环选项，选择【永远】或【1次】，存储，如下：]]></content>
      <categories>
        <category>IT实用技能</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>GIF</tag>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac屏幕录制GIF动图]]></title>
    <url>%2FMac%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6GIF%E5%8A%A8%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在 Mac 上最方便的录制屏幕 GIF 动图的方式就是利用 QQ 软件的录屏功能。效果图：教程：鼠标放在 QQ 聊天窗口中的“捕捉屏幕”上，选中“录屏”，如下：选择想要录屏的区域，如下：点击【开始录制】，如下：随后会显示之前录制的视频，选择【下载】，如下：在保存格式中选择 gif ，点击【存储】，如下：得到 GIF 动图，如下：后记：此时得到的 GIF 动图大小为1.9M，如果想对其大小做简单的压缩，可以用Mac自带的预览打开它。选择【文件】中的【导出】选项，如下：导出格式选择 gif ，点击【存储】，如下：可以看到，大小由原来的1.9M压缩为197K，如下：但是，如此大的压缩比，牺牲的是 GIF 无限循环播放的能力。如果不在意 GIF 动图仅能播放一次，那么可以使用此方法压缩；如果想要无限循环播放，又想极致压缩，请移步 用PS修改GIF动图循环播放次数 和 ImageOptim-无损图片压缩Mac版]]></content>
      <categories>
        <category>IT实用技能</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>GIF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之网站标题栏背景变色]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E7%BD%91%E7%AB%99%E6%A0%87%E9%A2%98%E6%A0%8F%E8%83%8C%E6%99%AF%E5%8F%98%E8%89%B2%2F</url>
    <content type="text"><![CDATA[效果图：教程打开themes/next/source/css/_custom/custom.styl，在里面新增如下代码：123.site-meta &#123; background: $blue; //天空的颜色，和我的眼镜是绝配&#125;]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题美化之顶部加载进度条]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E9%A1%B6%E9%83%A8%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[效果图：教程：进入博客文件夹的/themes/next文件夹下1cd /themes/next下载安装Progress module，如下1git clone https://github.com/theme-next/theme-next-pace source/lib/pace在/themes/next/_config.yml中设置，如下123456789# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true #是否开启进度条# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimal# For examplepace_theme: pace-theme-center-atom #选择进度条样式不同的样式效果图：pace-theme-big-counterpace-theme-bouncepace-theme-barber-shoppace-theme-center-atompace-theme-center-circlepace-theme-center-radarpace-theme-center-simplepace-theme-corner-indicatorpace-theme-fill-leftpace-theme-flashpace-theme-loading-barpace-theme-mac-osxpace-theme-minimal后记：我的网络时好时坏的，所以进度条也是录的时快时慢，请大家见谅。想知道怎么在Mac下高效的制作gif动图的小伙伴请移步至 Mac屏幕录制GIF动图为了让大家可以直观的查看进度条的效果，因此我录制了gif动图，如果您觉得这对您有帮助，请随意打赏或评论点赞，谢谢大家。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js安装教程]]></title>
    <url>%2FNodeJs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是Node.jsNodeJS官网上的介绍：Node.js is a platform built on Chrome’s JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.它是一个Javascript运行环境依赖于Chrome V8引擎进行代码解释事件驱动非阻塞I/O（NodeJS遇到I/O事件会创建一个线程去执行，然后主线程会继续往下执行的）轻量、可伸缩，适于实时数据交互应用单进程，单线程Node.js的优缺点NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景（高并发、聊天、实时消息推送）优点：高并发（最重要的优点）NodeJs更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）适合I/O密集型应用缺点：不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循 环），将会导致CPU时间片不能释放，使得后续I/O无法发起；解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起。只支持单核CPU，不能充分利用CPU；可靠性低，一旦代码某个环节崩溃，整个系统都崩溃（原因：单进程，单线程）；解决方案：Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；开多个进程监听同一个端口，使用cluster模块。Debug不方便，错误没有stack trace。Node.js的安装访问 Node.js 下载地址：https://nodejs.org/zh-cn/ ，下载最新版本。双击刚才下载文件，按照步骤默认安装。Node.js和npm安装完成。安装完成后打开终端，输入12npm -vnode -v两个命令，如下图出现版本信息，说明安装成功。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git安装教程]]></title>
    <url>%2FGit%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[打开终端，输入1git --version系统提示安装git待安装完毕，在终端再次输入1git --version如下图出现版本信息，说明安装成功。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Hexo创建个人博客]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。安装安装 Hexo 比较简单，但在安装前，需要安装如下应用程序。（如果您已经安装了如下程序，请直接执行第2步。）Node.js （安装教程）Git （安装教程）安装Hexo，打开终端，输入1npm install -g hexo-cli建站安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中创建博客框架。123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install新建完成后，指定文件夹的目录如下：_config.yml =&gt; 网站的 配置 信息，您可以在此配置大部分的参数。package.json =&gt; 应用程序的信息。scaffolds =&gt; 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。source =&gt; 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。themes =&gt; 主题文件夹。Hexo 会根据主题来生成静态页面。预览生成静态文件。在终端中输入1hexo generate启动服务器。在终端中输入1hexo server默认情况下，在浏览器中访问网址： http://localhost:4000/ 即可预览个人博客。写作你可以执行下列命令来创建一篇新文章。1hexo new &lt;title&gt;部署安装 hexo-deployer-git。1npm install hexo-deployer-git --save修改配置。12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] #published message: [message]参数描述repo库（Repository）地址branch分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测message自定义提交信息生成站点文件并推送至远程库。执行命令。1hexo clean &amp;&amp; hexo deploy前者清除站点文件，后者重新生成站点文件并将之推送到指定的库分支。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用vue-i18n实现中英文切换]]></title>
    <url>%2FVue%E4%B8%AD%E4%BD%BF%E7%94%A8vue-i18n%E5%AE%9E%E7%8E%B0%E4%B8%AD%E8%8B%B1%E6%96%87%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[安装依赖1npm install vue-i18n在main.js中引入并使用1234567891011import VueI18n from 'vue-i18n'Vue.use(VueI18n)const i18n = new VueI18n(&#123; locale: window.localStorage.getItem('user_lang') == null ? "cn" : window.localStorage.getItem('user_lang'), // 语言标识 messages: &#123; 'cn': require('./utils/lang/cn'), // 中文语言包 'en': require('./utils/lang/en') // 英文语言包 &#125;,&#125;)多语言的js文件cn.js文件内容：12345678module.exports = &#123; language: &#123; name: 'English' &#125;, login: &#123; welcome: '欢迎您' &#125;&#125;en.js文件内容：12345678module.exports = &#123; language: &#123; name: '中文' &#125;, login: &#123; welcome: 'Welcome' &#125;&#125;上面的name语言之所以是反的，是因为切换按钮的文字显示需要是反，即英文页面显示中文切换按钮，中文页面显示英文切换按钮。使用i18n12345678&lt;template&gt; &lt;p&gt;&#123;&#123; $t('language.name') &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; test() &#123; var name = this.$t('language.name') &#125;,&lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包工具Charles从入门到入土]]></title>
    <url>%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%2F</url>
    <content type="text"><![CDATA[简介Charles 是在 Mac 下常用的网络封包截取工具，通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。主要功能截取 Http 和 Https 网络封包；支持重发网络请求，方便后端调试；支持修改网络请求参数；支持网络请求的截获并动态修改；支持流量控制，可以模拟慢速网络以及等待时间（latency）较长的请求；支持AJAX调试，可以自动将json或xml数据格式化，方便查看；支持AMF调试，可以将Flash Remoting 或 Flex；Remoting信息格式化，方便查看；检查HTML，CSS和RSS内容是否符合W3C标准。安装官网下载 最新试用版安装。某云盘下载 完美版安装（密码：89pl）。设置系统代理紧接着，软件中就会出现抓取的网页信息：Charles 主要提供两种查看封包的视图，分为 Structure 和 Sequence：Structure 视图将网络请求按访问的域名分类；Sequence 视图将网络请求按访问的时间排序。获取手机上的网络封包打开代理功能在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图：获取电脑IPCharles 顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图：手机设置代理连接一定一定，手机和电脑要处于同一局域网下。 在手机的网络设置中，填入刚才获取到的电脑IP和 Charles 上设置的端口，如下图：完事之后，打开手机上任意需要联网的程序，就可以在 Charles 上看到请求连接的确认提示，点击确认，如下：截获 HTTPS必须安装Charles的CA证书，不然 HTTPS 的返回结果会是一堆乱码。首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图：如果我们需要在手机上截取 Https 的内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的安装教程。如下图：在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：chls.pro/ssl ，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 内容了。模拟低速网络在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图：如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下图：接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。反向代理Charles 的反向代理功能允许我们将本地的端口映射到远程的另一个端口上。例如，在下图中，我将本机的 8080 端口映射到了远程（pangao1990.github.io）的80端口上了。这样，当我访问本地的 8080 端口时，实际返回的内容会由 pangao1990.github.io 的 80 端口提供。修改服务器返回内容根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。Rewrite 功能适合对网络请求进行一些正则替换。Breakpoints 功能适合做一些临时性的修改。Map 功能Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 www.baidu.com 的请求重定向到了 pangao1990.github.io 。对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图），然后稍加修改，成为我们的目标映射文件。将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。Rewrite 功能Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。例如，我博客返回的昵称是“潘高”，我现在要改成“大帅哥”，如下图：Breakpoints 功能上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。]]></content>
      <categories>
        <category>IT实用技能</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Office-办公软件套装Mac绿色版]]></title>
    <url>%2FOffice-%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%E5%A5%97%E8%A3%85Mac%E7%BB%BF%E8%89%B2%E7%89%88%2F</url>
    <content type="text"><![CDATA[简介：Microsoft Office是微软公司开发的一套办公软件套装。常用组件有 Word、Excel、PowerPoint等。Microsoft Office Word 是文字处理软件，Microsoft Office Excel 是电子数据表程序〔进行数字和预算运算的软件程序〕，Microsoft Office PowerPoint 是演示文稿软件，Microsoft Office Outlook 是个人信息管理程序和电子邮件通信软件，Microsoft Office FrontPage 是一款网页设计、制作、发布、管理的软件，Microsoft Office OneNote 使您能够捕获、组织和重用便携式计算机、台式计算机或Tablet PC上的便笺等等。功能特点：Word —— 创建、完善和共享既美观又专业的文档Excel —— 以新颖直观的方式分析和可视化数字PowerPoint —— 创建多媒体演示文稿并自信地展示想法OneNote —— 在完全属于自己的数字笔记本中记录想法Outlook —— 外观精美的电子邮件和日历，帮助你快速保持井然有序破解教程：压缩包内含教程。下载地址：V16.24版-云盘下载 密码: 1fdodmg打开密码: blog.pangao.vip本软件来源于网络，仅供学习使用，请在24小时内删除，本人不承担任何相关责任！若侵犯某些组织或个人的权益，请联系我删除。]]></content>
      <categories>
        <category>Mac软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS检测对象中是否存在某个属性]]></title>
    <url>%2FJS%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[使用in关键字该方法可以判断对象的自有属性和继承来的属性是否存在。1234var o=&#123;x:1&#125;;"x" in o; //true，自有属性存在"y" in o; //false"toString" in o; //true，是一个继承属性使用对象的hasOwnProperty()方法该方法只能判断自有属性是否存在，对于继承属性会返回false。1234var o=&#123;x:1&#125;;o.hasOwnProperty("x"); //true，自有属性中有xo.hasOwnProperty("y"); //false，自有属性中不存在yo.hasOwnProperty("toString"); //false，这是一个继承属性，但不是自有属性使用undefined判断自有属性和继承属性均可判断。1234var o=&#123;x:1&#125;;o.x!==undefined; //trueo.y!==undefined; //falseo.toString!==undefined //true该方法存在一个问题，如果属性的值就是undefined的话，该方法不能返回想要的结果，如下:1234var o=&#123;x:undefined&#125;;o.x!==undefined; //false，属性存在，但值是undefinedo.y!==undefined; //falseo.toString!==undefined //true在条件语句中判断12var o=&#123;&#125;;if(o.x) o.x+=1; //如果x是undefine,null,false," ",0或NaN,它将保持不变]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的深拷贝与浅拷贝]]></title>
    <url>%2FJS%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深拷贝：1arr1 = JSON.parse(JSON.stringify(arr2))修改arr2，不会影响到arr1。因为arr1和arr2指向不同的地址。浅拷贝：1arr1 = arr2修改arr2，arr1会改变。因为arr1和arr2指向同一的地址。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacBooster-系统清理和优化工具Mac绿色版]]></title>
    <url>%2FMacBooster-%E7%B3%BB%E7%BB%9F%E6%B8%85%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7Mac%E7%BB%BF%E8%89%B2%E7%89%88%2F</url>
    <content type="text"><![CDATA[简介：MacBooster是Mac os平台上的帮助用户有效清理系统缓存的Mac系统清理工具，MacBooster 还可以帮助用户提升开机的时间，优化系统自定义启动项，使电脑长时间使用都不会出现卡顿现象，操作非常的简单。功能特点：系统状态：通过运行全面的扫描来探索Mac的状态。病毒和恶意软件扫描：快速，深入地分析您的Mac的安全状态。安全地删除威胁，使您的Mac保持安全。隐私清除：通过运行全面扫描来探索Mac的状态。系统垃圾：扫描系统的每一个角落，找出垃圾文件，保持硬盘的浪费。卸载程序：帮助摆脱不需要的应用程序或剩下的文件。大文件清理器：查找并删除不再需要的大文件，以释放更多的空间。内存清理：清理以重新获得更多可用的RAM，并使应用程序启动更快。启动优化：管理启动项以优化OS X引导速度。碎片整理：通过一键式优化和修复磁盘的新功能。重复查找器：快速找到并删除Mac上重复的文件。照片扫描器：有效快速地找到类似或重复的照片。保持最美丽的。制作的新迷你：增加实时监控网络速度和通知扫描和修复结果。破解教程：直接安装即可。下载地址：V7.2.3版-云盘下载 密码: ut03dmg打开密码: blog.pangao.vip本软件来源于网络，仅供学习使用，请在24小时内删除，本人不承担任何相关责任！若侵犯某些组织或个人的权益，请联系我删除。]]></content>
      <categories>
        <category>Mac软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中添加友盟代码统计]]></title>
    <url>%2FVue%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%8F%8B%E7%9B%9F%E4%BB%A3%E7%A0%81%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[如下图所示：在入口App.vue中添加代码：123456789101112131415161718192021&lt;script&gt;export default &#123; name: 'app', mounted () &#123; const script = document.createElement('script') script.src = 'https://s95.cnzz.com/z_stat.php?id=1111111111&amp;web_id=1111111111' script.language = 'JavaScript' document.body.appendChild(script) &#125;, watch: &#123; '$route' () &#123; if (window._czc) &#123; let location = window.location let contentUrl = location.pathname + location.hash let refererUrl = '/' window._czc.push(['_trackPageview', contentUrl, refererUrl]) &#125; &#125; &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序与vue的一些区别]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8Evue%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1、条件渲染vue使用 v-if v-else-if v-else 指令，如下：123&lt;div v-if="color=='red'"&gt;red&lt;div&gt;&lt;div v-else-if="color=='orange'"&gt;orange&lt;div&gt;&lt;div v-else&gt;yellow&lt;div&gt;wx使用 wx:if wx:elif wx:else 指令，如下：123&lt;view wx:if="&#123;&#123;color=='red'&#125;&#125;"&gt;red&lt;view&gt;&lt;view wx:elif="&#123;&#123;color=='orange'&#125;&#125;"&gt;orange&lt;view&gt;&lt;view wx:else&gt;yellow&lt;view&gt;2、显示隐藏元素vue使用 v-show 指令，如下：1&lt;div v-show="color=='red'"&gt;red&lt;div&gt;wx使用 hidden 指令，如下：1&lt;view hidden="&#123;&#123;color=='red'&#125;&#125;"&gt;red&lt;view&gt;3、绑定classvue使用 v-bind: 或简写为 ： 指令，如下：1&lt;div :class="&#123; 'class-a': isA &#125;"&gt;red&lt;div&gt;Javascript代码：123data: &#123; isA: false //当isA改变时，将更新class&#125;wx，如下：1&lt;view class="&#123;&#123; isA ? 'class-a':'' &#125;&#125;"&gt;red&lt;view&gt;Javascript代码：123data: &#123; isA: false //当isA改变时，将更新class&#125;4、事件处理vue使用 v-on: 或 @ 指令绑定事件，如下：1&lt;div v-on:click="counter += 1"&gt;Add 1&lt;div&gt;wx使用 baintap 指令，如下：1&lt;view bindtap="clickMe"&gt;click&lt;view&gt;5、绑定值vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号 ： ，如下：1&lt;img :src="imgSrc"/&gt;wx绑定某个变量的值为元素属性时，会用两个大括号括起来，如下：1&lt;img src="imgSrc"/&gt;6、绑定事件传参vue绑定事件的函数传参数时，可以把参数写在函数后面的括号里，如下：1&lt;div @click="changeTab(1)"&gt;嚯嚯&lt;/div&gt;wx绑定事件的函数传参数时，可以绑定到元素中，在函数中获取，如下：1&lt;view bindtap="changeTab()" data-tab="1"&gt;嚯嚯&lt;/view&gt;Javascript代码：`jschangeTab(e) {var tab = e.currentTarget.dataset.tab }7、设置值vue设置test的值可以用，this.test = true ；获取test的值可以用 this.test 。wx设置test的值要用 this.setData({test:true}) ；获取test的值用 this.data.test 。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中setData的key是变量怎么办]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%ADsetData%E7%9A%84key%E6%98%AF%E5%8F%98%E9%87%8F%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[代码如下：123456onclick: function (e) &#123; var id = e.target.id this.setData(&#123; id: e.detail.value &#125;)&#125;显然data中是多了一个 id 的数据，解决办法是用[]将变量括起来，如下：123456onclick: function (e) &#123; var id = e.target.id this.setData(&#123; [id]: e.detail.value &#125;)&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中用setData修改数组或对象]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%94%A8setData%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%88%96%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在 page 中有如下数组：123456789101112131415161718Page(&#123; data: &#123; list: [ &#123; id: 0, state: "running" &#125;, &#123; id: 1, state: "done" &#125;, &#123; id: 2, state: "error" &#125; ] &#125;&#125;)若需要使用 setData 修改 list[0].state 的值为 done，若直接修改，如下：显然报错了，解决方法如下：先用一个字符串变量表示 list[0].state ；再将该字符串变量用[]括起来。如下：]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中的渐变色]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%B8%90%E5%8F%98%E8%89%B2%2F</url>
    <content type="text"><![CDATA[CSS3 渐变（gradients）可以在两个或多个指定的颜色之间显示平稳的过渡。CSS3 定义了两种类型的渐变（gradients）：线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向径向渐变（Radial Gradients）- 由它们的中心定义线性渐变 - 从上到下（默认情况下）123.gradual&#123; background: linear-gradient(red, orange); &#125;线性渐变 - 从左到右123.gradual&#123; background: linear-gradient(to right, red, orange); &#125;线性渐变 - 对角123.gradual&#123; background: linear-gradient(to bottom right, red, orange); &#125;线性渐变 - 带有指定的角度123.gradual&#123; background: linear-gradient(60deg, red, orange); &#125;线性渐变 - 从上到下，带有多个颜色结点123.gradual&#123; background: linear-gradient(red, orange, yellow); &#125;线性渐变 - 带有彩虹颜色123.gradual&#123; background: linear-gradient(red, orange, yellow, green, blue, indigo, violet); &#125;线性渐变 - 带有透明度123.gradual&#123; background: linear-gradient(rgba(255,0,0,1), rgba(255,0,0,0)); &#125;重复线性渐变 - repeating-linear-gradient()函数123.gradual&#123; background: repeating-linear-gradient(red, orange, yellow 10%); &#125;径向渐变 - 颜色结点均匀分布（默认情况下）123.gradual&#123; background: radial-gradient(red, orange, yellow); &#125;径向渐变 - 颜色结点不均匀分布123.gradual&#123; background: radial-gradient(red 5%, orange 20%, yellow 80%); &#125;重复径向渐变 - repeating-radial-gradient()函数123.gradual&#123; background: repeating-radial-gradient(red, orange, yellow 10%); &#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序如何获取屏幕的高度和宽度]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E7%9A%84%E9%AB%98%E5%BA%A6%E5%92%8C%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[微信小程序如何获取屏幕的高度和宽度方法一：12var windowHeight = wx.getSystemInfoSync().windowHeightvar windowWidth = wx.getSystemInfoSync().windowWidth方法二：1234.windowHeightWidthClass &#123; height: 100vh; width: 100vw;&#125;CSS3中的 vh 和 vw 是相对于屏幕大小的单位，即：vh =&gt; view heightvw =&gt; view width]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UltraEdit-文本编辑器Mac绿色版]]></title>
    <url>%2FUltraEdit-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8Mac%E7%BB%BF%E8%89%B2%E7%89%88%2F</url>
    <content type="text"><![CDATA[简介：Ultraedit是一款在Windows系统中非常出名的文本编辑器，可以编辑文本、十六进制、ASCII 码，完全可以取代其他文本工具，同时还支持许多开发语言，如 C, Objective C, Javascript, XML, PHP, Perl, Python等，并可同时编辑多个文件，而且即使开启很大的文件速度也不会慢。功能特点：可配置语法加亮，支持代码折叠、Unicode；基于磁盘的文本编辑和支持超过 4GB 的大文件处理，即使是数兆字节的文件也只占用极少的内存；在所有搜索操作（查找、替换、在文件中查找、在文件中替换）中，支持多行查找和替换对话框；带有 100,000 个单词的拼写检查器，对 C/C++、VB、HTML、Java 和 Perl 进行了预配置；内置 FTP 客户端，支持登录和保存多个账户，支持SSH/Telnet 窗口；提供预定义的或用户创建的编辑“环境”，能记住 UltraEdit 的所有可停靠窗口、工具栏等的状态；集成脚本语言以自动执行任务，可配置键盘映射，列/块模式编辑，命名的模板；十六进制编辑器可以编辑任何二进制文件，并显示二进制和 ASCII 视图；HTML 工具栏，对常用的 HTML 功能作了预配置；文件加密/解密；多字节和集成的 IME。网络搜索工具栏：高亮显示文本并单击网络搜索工具栏按钮，从编辑器内启动搜索加亮词语。破解教程：直接安装即可。下载地址：V18.0.00.40版-云盘下载 密码: 8uqidmg打开密码: blog.pangao.vip本软件来源于网络，仅供学习使用，请在24小时内删除，本人不承担任何相关责任！若侵犯某些组织或个人的权益，请联系我删除。]]></content>
      <categories>
        <category>Mac软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中动态设置页面title]]></title>
    <url>%2FVue%E4%B8%AD%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2title%2F</url>
    <content type="text"><![CDATA[安装依赖1npm install vue-wechat-title --save在mian.js中引入123//设置titleimport VueWechatTitle from 'vue-wechat-title'Vue.use(VueWechatTitle)在router的index.js的路由中加上参数1234567&#123; path: '/login', component: Login, meta: &#123; title: '登录' &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用base64编码和解码]]></title>
    <url>%2FVue%E4%B8%AD%E4%BD%BF%E7%94%A8base64%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在项目根目录下安装1npm install --save js-base64在项目文件中引入1let Base64 = require('js-base64').Base64在项目文件中使用12Base64.encode('潘高') // 5r2Y6auYBase64.decode('5r2Y6auY') // 潘高]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Perl递归删除文件夹及其内容]]></title>
    <url>%2FPerl%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%8A%E5%85%B6%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[123use File::Path qw(remove_tree);remove_tree($zipFiles."/tem/");]]></content>
      <categories>
        <category>Perl</category>
      </categories>
      <tags>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Perl解压zip]]></title>
    <url>%2FPerl%E8%A7%A3%E5%8E%8Bzip%2F</url>
    <content type="text"><![CDATA[12345678910111213use Archive::Zip;my $obj = Archive::Zip-&gt;new();$status = $obj-&gt;read($fileFrom);if ($status != AZ_OK) &#123; print "=====程序终止！=====\n解压失败\n"; #保留黑框 system pause; #程序停止运行 die;&#125; else &#123; $obj-&gt;extractTree(undef, $fileTo);&#125;]]></content>
      <categories>
        <category>Perl</category>
      </categories>
      <tags>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用生物信息学格式介绍]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[fastafasta （维基百科）格式是最基本的表示序列信息（核苷酸或者蛋白质）的格式。这里简单介绍下，fasta格式的文件通常后缀名为 .fasta 或者 .fa ，其实这都无所谓，因为都是文本文件。 fasta 格式文件（可以包含多条序列）中的一条序列的通常表示方法如下：12345&gt;gi|129295|sp|P01013|OVAX_CHICK GENE X PROTEIN (OVALBUMIN-RELATED)QIKDLLVSSSTDLDTTLVLVNAIYFKGMWKTAFNAEDTREMPFHVTKQESKPVQMMCMNNSFNVATLPAEKMKILELPFASGDLSMLVLLPDEVSDLERIEKTINFEKLTEWTNPNTMEKRRVKVYLPQMKIEEKYNLTSVLMALGMTDLFIPSANLTGISSAESLKISQAVHGAFMELSEDGIEMAGSTGVIEDIKHSPESEQFRADHPFLFLIKHNPTNTIVYFGRYWSP其中主要分为两个部分：第一部分是序列的定义行（单行），该行的开头是&gt;符号，紧跟着后面的就是该条序列的名称（具有唯一性，即不能和其它序列同名称），即&gt;号和后面的名称的第一字符间是没有任何空白的。一般第一个空格后面的内容即为可选的描述信息。如上面， gi|129295|sp|P01013|OVAX_CHICK为序列名称， 而GENE X PROTEIN (OVALBUMIN-RELATED)则为描述信息。注意：有点软件是把一整行当做名称的，所以在出现错误的时候可以查看下格式是否正确。第二部分就是序列，所有的序列碱基或者氨基酸可以都放在一行存储，也可以多行存储，但是建议大家多行存储且单行长度不超过80个字符，因为这样容易阅读。且序列的多行之间不能有空行，序列信息描述的第一行与序列数据的第一行之间不能有空行。其中序列数据主要是按照密码表来表示的，*表示是蛋白质翻译的结束。多行序列举例如下：12345678&gt;SEQUENCE_1MTEITAAMVKELRESTGAGMMDCKNALSETNGDFDKAVQLLREKGLGKAAKKADRLAAEGLVSVKVSDDFTIAAMRPSYLSYEDLDMTFVENEYKALVAELEKENEERRRLKDPNKPEHKIPQFASRKQLSDAILKEAEEKIKEELKAQGKPEKIWDNIIPGKMNSFIADNSQLDSKLTLMGQFYVMDDKKTVEQVIAEKEKEFGGKIKIVEFICFEVGEGLEKKTEDFAAEVAAQL&gt;SEQUENCE_2SATVSEINSETDFVAKNDQFIALTKDTTAHIQSNSLQSVEELHSSTINGVKFEEYLKSQIATIGENLVVRRFATLKAGANGVVNGYIHTNGRVGVVIAAACDSAEVASKSRDLLRQICMHfastqfastq 同样是以文本形式来存储序列信息的格式，后缀名通常为 .fastq 或者 .fq ，但是与 fasta 不相同的是，它除了存储序列本身外还存储了序列中每个单元所对应的质量分数，所以 fastq 格式通常用于高通量测试数据的存储。早期是有 Sanger 机构开发的，但是现在已经演变成一个高通量测序的标准了。fastq 格式文件中一个完整的单元分为四行，每行的含义如下：第一行： 以@开头，内容同fasta的描述行类似第二行：具体的碱基序列第三行：以+开头，后面的内容可以和第一行类似，也什么都没有只留+第四行：以ASCII字符集（分数）编码来表示对应碱基的测序质量比如下面的这个例子：1234@SEQ_IDGATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT+!&apos;&apos;*((((***+))%%%++)(%%%%).1***-+*&apos;&apos;))**55CCF&gt;&gt;&gt;&gt;&gt;&gt;CCCCCCC65下面以Illumina和NCBI SRA两个测序数据来源来讲讲它们之间的区别：通常我们获取测序数据有两种途径，一种是自己通过仪器测定，一种是在公共数据库中(比如之前说到的 NCBI 中的 SRA 数据库)获取，这两种方式主要是在序列名称的命名上和测序质量表示方式上有所不同。Illumina 序列名称：1@HWUSI-EAS100R:6:73:941:1973#0/1上述以：隔开的每个字段的含义如下：HWUSI-EAS100Rthe unique instrument name6flowcell lane3tile number within the flowcell lane941‘x’-coordinate of the cluster within the tile1973‘y’-coordinate of the cluster within the tile#0index number for a multiplexed sample (0 for no indexing)/1the member of a pair, /1 or /2 (paired-end or mate-pair reads only)NCBI SRA 数据库将测序数据提交到 NCBI 的 SRA 数据库时， SRA 数据库会为每一个样本提供一个编号，一般是 SRRxxxxx ，所以从 SRA 数据库上下载公共的测试数据（原始格式为 .sra ， 需特定工具转换为 fastq ），其 fastq 格式文件中每个单元的名称是以 SRA 编号接数字加以区分的。比如下面的这个示例：1234@SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345 length=36GGGTGATGGCCGCTGCCGATGGCGTCAAATCCCACC+SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345 length=36IIIIIIIIIIIIIIIIIIIIIIIIIIIIII9IG9IC需要注意的是：当把测序数据上传到 SRA 数据库时，它通常会将表示质量的分数 转换为标准的 Sanger 格式 。质量分数表示法：由于测序仪器的不同等因素所以对碱基测序质量的表示方式也不相同，在 Fastq 格式文件中，用ASCII码表来表示每个碱基的测序质量，下面介绍几种不同的方案：其中有五种表示方法，Sanger 的码表范围为 ! 至 I ，其对应的数值为 33-73，如果减去 33（即 Phred + 33 表示法）这个基数则范围转换为 0-40，即如果某一个碱基的测序质量为 ! 则对应的测序质量分数为 0，表示测序质量低。其它几种表示法类似（X,I,J,L）。这里介绍测序质量的表示方法是因为后面有的软件是要指定测序数据的质量表示方法。gff2GFF(General Feature Format)是一种用于描述基因或者其它序列元素的文件格式，GFF 有几个版本，早期的第 Version 2 和现在的 Version 3. Version 2 是由 Sanger 机构所制定的，而 Version 3 是由 Sequence Ontology Project 制定。正是由于有统一的格式来表示基因等元素，使得 GFF 格式的文件被广泛的使用与 mapping 与基因组数据可视化方面。GFF2 文件格式是由 tab 隔开的九列值，每一行的九个字段的含义如下：1Chr1 curated CDS 365647 365963 . + 1 Transcript &quot;R119.7&quot;第一列： reference sequence， 该列表示的是特征元素所在的染色体（或者scaffold，或者contig），也就是在基因组中的坐标系统，后续一切的注释信息都是基于此列。第二列：source，该列表示改行注释信息的来源，比如上述的一行表示该行的CDS注释信息来自名为“curated”的注释。第三列：feature，或者说是method，type， 表示的是该注释的类型，比如上述表示改行注释为CDS信息，可以将source和feature结合起来描述的更加详细。第四列：start position，在reference sequence上的开始位置（坐标），通常是从1为起点而不是0。第五列：end position， 在reference sequence上的结束位置（坐标），一般是大于start position的。第六列：score， 表示该行feature的分数，比如序列相似性等，如果没有对应的分数可以用.代替。第七列：strand，feature所在链，+表示正链，-表示负链，.表示不确定或者与链无关。第八列：phase，与蛋白质编码相关，一般是用于CDS，值的范围为0-2，表示编码时阅读框的移动相位。下面这段描述很详细:‘0’ indicates that the specified region is in frame, i.e. that its first base corresponds to the first base of a codon. ‘1’ indicates that there is one extra base, i.e. that the second base of the region corresponds to the first base of a codon, and ‘2’ means that the third base of the region is the first base of a codon. If the strand is ‘-‘, then the first base of the region is value of, because the corresponding coding region will run fromtoon the reverse strand.第九列：group，或者称为attributes，是用于对改行注释更多的描述，以键值对的形式，比如上面的例子表示该CDS是属于名为R119.7的transcript。该列中可以存在多个属性，属性之间是用;隔开的。对于GFF格式的理解主要是集中在最后一列，有以下集中情况：对于单个feature1Chr3 giemsa heterochromatin 4500000 6000000 . . . Band 3q12.1对于属于同一集合的多个feature1234IV curated exon 5506900 5506996 . + . Transcript B0273.1IV curated exon 5506026 5506382 . + . Transcript B0273.1IV curated exon 5506558 5506660 . + . Transcript B0273.1IV curated exon 5506738 5506852 . + . Transcript B0273.1比如上面这个例子就表示这四个exon都是属于同一个名为B0273.1的transcript，这是表示一个完整transcript结构的最基本要求。GFF2还可用于序列比对结果表示等其它方面，这里不做介绍了。gtf(gff2.5)GTF（Gene Transfer Format）格式是借鉴于GFF2格式，也被称为GFF2.5，大部分字段的定义是和GFF2相同的，只是每行的第九列必须带有如下四个域，具体为gene_id value; transcript_id value; 这样的设计是为了适应一个基因的多个转录本这种情况。比如下面的这个例子：123456AB000123 Twinscan CDS 193817 194022 . - 2 gene_id &quot;AB000123.1&quot;; transcript_id &quot;AB00123.1.2&quot;;AB000123 Twinscan CDS 199645 199752 . - 2 gene_id &quot;AB000123.1&quot;; transcript_id &quot;AB00123.1.2&quot;;AB000123 Twinscan CDS 200369 200508 . - 1 gene_id &quot;AB000123.1&quot;; transcript_id &quot;AB00123.1.2&quot;;AB000123 Twinscan CDS 215991 216028 . - 0 gene_id &quot;AB000123.1&quot;; transcript_id &quot;AB00123.1.2&quot;;AB000123 Twinscan start_codon 216026 216028 . - . gene_id &quot;AB000123.1&quot;; transcript_id &quot;AB00123.1.2&quot;;AB000123 Twinscan stop_codon 193814 193816 . - . gene_id &quot;AB000123.1&quot;; transcript_id &quot;AB00123.1.2&quot;;gff3GFF2（维基百科）格式早期用的比较多，但是现在用的多的是GFF3格式，这也是好多软件所支持的，比如Gbrowse， Jbrowse等基因组数据可视化工具。先看下面这个简单的例子：123456##gff-version 3ctg123 . exon 1300 1500 . + . ID=exon00001ctg123 . exon 1050 1500 . + . ID=exon00002ctg123 . exon 3000 3902 . + . ID=exon00003ctg123 . exon 5000 5500 . + . ID=exon00004ctg123 . exon 7000 9000 . + . ID=exon00005第一行的##gff-version 3通常是需要的，而且必须是在文件的第一行。前八列和GFF2、GFF2.5类似，但是有几点是要特别注意的，主要是将GFF3注释数据用于基因组浏览器时，字段中的一些特殊字符比如空格，&gt; %等都需要使用URL编码进行转换才能准确的在web中进行展示。第九列同样是表示attributes，采用的同样是键值对的形式（tag=value），只是这里有几个特定的键，具体如下：ID，feature在整个GFF3文件中唯一的标识符；Name，feature的名字，不同于ID，Name不要求唯一，只是方便用户浏览；Alias， 相当于feature的别名；Parent，表明该feature所属的上一级feature 的ID，这种关系可用于exons-transcripts，transcripts-genes，可以看出一个feature可以拥有多个子feature；Target， 主要是用于序列比对结果的展示，value的格式为target_id start end [strand], 其中如果target_id中含有空格则需转换为%20；后面还有些其它属性比如Note等，这里不再做详细描述。下面再来看下典型的例子：蛋白质编码基因结构123456789101112131415161718192021222324ctg123 example gene 1050 9000 . + . ID=EDEN;Name=EDEN;Note=protein kinasectg123 example mRNA 1050 9000 . + . ID=EDEN.1;Parent=EDEN;Name=EDEN.1;Index=1ctg123 example five_prime_UTR 1050 1200 . + . Parent=EDEN.1ctg123 example CDS 1201 1500 . + 0 Parent=EDEN.1ctg123 example CDS 3000 3902 . + 0 Parent=EDEN.1ctg123 example CDS 5000 5500 . + 0 Parent=EDEN.1ctg123 example CDS 7000 7608 . + 0 Parent=EDEN.1ctg123 example three_prime_UTR 7609 9000 . + . Parent=EDEN.1ctg123 example mRNA 1050 9000 . + . ID=EDEN.2;Parent=EDEN;Name=EDEN.2;Index=1ctg123 example five_prime_UTR 1050 1200 . + . Parent=EDEN.2ctg123 example CDS 1201 1500 . + 0 Parent=EDEN.2ctg123 example CDS 5000 5500 . + 0 Parent=EDEN.2ctg123 example CDS 7000 7608 . + 0 Parent=EDEN.2ctg123 example three_prime_UTR 7609 9000 . + . Parent=EDEN.2ctg123 example mRNA 1300 9000 . + . ID=EDEN.3;Parent=EDEN;Name=EDEN.3;Index=1ctg123 example five_prime_UTR 1300 1500 . + . Parent=EDEN.3ctg123 example five_prime_UTR 3000 3300 . + . Parent=EDEN.3ctg123 example CDS 3301 3902 . + 0 Parent=EDEN.3ctg123 example CDS 5000 5500 . + 1 Parent=EDEN.3ctg123 example CDS 7000 7600 . + 1 Parent=EDEN.3ctg123 example three_prime_UTR 7601 9000 . + . Parent=EDEN.3一个名为EDEN的基因拥有三个转录本，分别名为EDEN.1 EDEN.2 EDEN.3， 每个转录本又有UTR和CDS等信息。序列比对123456789ctg123 est EST_match 1050 1500 . + . ID=Match1;Name=agt830.5;Target=agt830.5 1 451ctg123 est EST_match 3000 3202 . + . ID=Match1;Name=agt830.5;Target=agt830.5 452 654ctg123 est EST_match 5410 5500 . - . ID=Match2;Name=agt830.3;Target=agt830.3 505 595ctg123 est EST_match 7000 7503 . - . ID=Match2;Name=agt830.3;Target=agt830.3 1 504ctg123 est EST_match 1050 1500 . + . ID=Match3;Name=agt221.5;Target=agt221.5 1 451ctg123 est EST_match 5000 5500 . + . ID=Match3;Name=agt221.5;Target=agt221.5 452 952ctg123 est EST_match 7000 7300 . + . ID=Match3;Name=agt221.5;Target=agt221.5 953 1253定量数据123456ctg123 affy microarray_oligo 1 100 281 . . Name=Expt1ctg123 affy microarray_oligo 101 200 183 . . Name=Expt1ctg123 affy microarray_oligo 201 300 213 . . Name=Expt1ctg123 affy microarray_oligo 301 400 191 . . Name=Expt1ctg123 affy microarray_oligo 401 500 288 . . Name=Expt1ctg123 affy microarray_oligo 501 600 184 . . Name=Expt1含Fasta格式的GFF3格式文件123456789101112131415##gff-version 3ctg123 . exon 1300 1500 . + . ID=exon00001ctg123 . exon 1050 1500 . + . ID=exon00002ctg123 . exon 3000 3902 . + . ID=exon00003ctg123 . exon 5000 5500 . + . ID=exon00004ctg123 . exon 7000 9000 . + . ID=exon00005##FASTA&gt;ctg123cttctgggcgtacccgattctcggagaacttgccgcaccattccgccttgtgttcattgctgcctgcatgttcattgtctacctcggctacgtgtggctatctttcctcggtgccctcgtgcacggagtcgagaaaccaaagaacaaaaaaagaaattaaaatatttattttgctgtggtttttgatgtgtgttttttataatgatttttgatgtgaccaattgtacttttcctttaaatgaaatgtaatcttaaatgtatttccgacgaattcgaggcctgaaaagtgtgacgccattc...该GFF3文件中含有对应的序列，以##FASTA作为标示。bedbed（genome介绍、bedtools介绍、 asia介绍）格式同样是用于展示序列注释信息，有相应的软件来处理这类格式的文件，如bedtools。可以用在类似GBrowse这样的基因组数据可视化工具中。 以tab隔开，它必须的三个字段为 chrom、chromStart、chromEnd，还有9个可选字段。注意：用于在GBrowse上展示相关注释的bed格式通常第一行有一个关于track的描述信息。比如下面的例子：123track name=pairedReads description=&quot;Clone Paired Reads&quot; useScore=1chr22 1000 5000 cloneA 960 + 1000 5000 0 2 567,488, 0,3512chr22 2000 6000 cloneB 900 - 2000 6000 0 2 433,399, 0,3601sam/bamhttp://blog.sina.com.cn/s/blog_670445240101l30k.htmlhttp://genome.sph.umich.edu/wiki/SAMhttps://samtools.github.io/hts-specs/SAMv1.pdf在生物信息学中尤其是高通量测序数据分析中，大部分的操作都是在实现短片段序列与参考序列的比对（mapping），比如bowtie等，这就涉及到如何使用一个统一的格式来表示这种mapping结果呢，sam（Sequence Alignment/Map）格式就是来解决这个问题的。sam文件拥有头部描述和详细比对两部分，其中头部描述是以@开头，后面紧跟两个缩写字母表示相应的含义，SAM分为两部分，注释信息（header section）和比对结果部分（alignment section），注释信息可有可无，都是以@开头，用不同的tag表示不同的信息，主要有@HD，说明符合标准的版本、对比序列的排列顺序；@SQ，参考序列说明；@RG，比对上的序列（read）说明；@PG，使用的程序说明；@CO，任意的说明信息。而详细比对部分是通过11个tab隔开的字段来表示。下面主要讲解下详细比对部分字段的具体含义：其中：QNAME 表示的是查询序列的名称即短片段（reads）的名称；FLAG 以整数来表示比对的结果，不同数值有不同的意义，数值也可以是下列数的组合；比如如果FLAG是4的话则表示该reads没有比对到参考序列上，flag为16表示single-end reads比对到参考序列的反链上，flag为83（64+16+2+1）表示paired-end reads中的第一个reads比对到参考序列上了。RNAME 表示参考序列的名称，比如基因组的染色体编号等，如果没有比对上则显示为*；POS 表示比对的起始位置，以1开始计数，如果没有比对上则显示为0；MAPQ 比对质量；CIGAR CIGAR 字符串，即比对的详细情况，简要比对信息表达式（Compact Idiosyncratic Gapped Alignment Report），其以参考序列为基础，使用数字加字母表示比对结果，比如3S6M1P1I4M，前三个碱基被剪切去除了，然后6个比对上了，然后打开了一 个缺口，有一个碱基插入，最后是4个比对上了，是按照顺序的；RNEXT 双末端测序中下一个reads比对的参考系列的名称，如果没有则用*表示，如果和前一个reads比对到同一个参考序列则用=表示；PNEXT 下一个reads比对到参考序列上的位置，如果没有则用0表示；ISIZE/TLEN query序列的模板长度或者插入长度，Template的长度，最左边得为正，最右边的为负，中间的不用定义正负，不分区段（single-segment)的比对上，或者不可用时，此处为0；reads的序列信息；reads的序列质量信息，同FASTQ。后面还有些可选字段，比如：可选字段（optional fields)，格式如：TAG:TYPE:VALUE，其中TAG有两个大写字母组成，每个TAG代表一类信息，每一行一个TAG只能出现一次，TYPE表示TAG对应值的类型，可以是字符串、整数、字节、数组等。示例：1234:497:R:-272+13M17D24M 113 1 497 37 37M 15 100338662 0 CGGGTCTGACCTGAGGAGAACTGTGCTCCGCCTTCAG 0;==-==9;&gt;&gt;&gt;&gt;&gt;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; XT:A:U NM:i:0 SM:i:37 AM:i:0 X0:i:1 X1:i:0 XM:i:0 XO:i:0 XG:i:0 MD:Z:37:20389:F:275+18M2D19M 99 1 17644 0 37M = 17919 314 TATGACTGCTAATAATACCTACACATGTTAGAACCAT &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&lt;&gt;&gt;4::&gt;&gt;:&lt;9 RG:Z:UM0098:1 XT:A:R NM:i:0 SM:i:0 AM:i:0 X0:i:4 X1:i:0 XM:i:0 XO:i:0 XG:i:0 MD:Z:37:20389:F:275+18M2D19M 147 1 17919 0 18M2D19M = 17644 -314 GTAGTACCAACTGTAAGTCCTTATCTTCATACTTTGT ;44999;499&lt;8&lt;8&lt;&lt;&lt;8&lt;&lt;&gt;&lt;&lt;&lt;&lt;&gt;&lt;7&lt;;&lt;&lt;&lt;&gt;&gt;&lt;&lt; XT:A:R NM:i:2 SM:i:0 AM:i:0 X0:i:4 X1:i:0 XM:i:0 XO:i:1 XG:i:2 MD:Z:18^CA19:21597+10M2I25M:R:-209 83 1 21678 0 8M2I27M = 21469 -244 CACCACATCACATATACCAAGCCTGGCTGTGTCTTCT &lt;;9&lt;&lt;5&gt;&lt;&lt;&lt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;&gt;&lt;9&gt;&gt;&lt;&gt;&gt;&gt;9&gt;&gt;&gt;&lt;&gt; XT:A:R NM:i:2 SM:i:0 AM:i:0 X0:i:5 X1:i:0 XM:i:0 XO:i:1 XG:i:2 MD:Z:35解释：其中可以看出Aligenment 2 和 Alignment 3是成对的reads，其插入长度为314。bam格式中的b是binary的意思，是sam格式的二进制表示方式，为什么要用二进制表示呢？ 因为sam格式文件大小通常是十分大的，一般是以G为单位，所以为了减少存储量等因素而将sam转换为二进制格式以便于分析。sam/bam格式是由特定的一些软件（比如samtools）来处理的，包括格式互转、排序、建立索引、搜寻突变等操作，后续分析中会详细讲解samtools工具的使用方法。vcfvcf（Variant Call Format）格式是用于表示突变信息的文本格式，可以用来表示single nucleotide variants, insertions/deletions, copy number variants and structural variants等。VCF格式同样是分为两大部分，一部分是注释描述信息，一部分是具体的突变信息，其中注释信息是以##开头的，我们来看下面这个例子：我们着重来关注第二部分的每列字段是什么含义：CHROM 即chromosome， 染色体名称；POS 即position， 发生突变的参考序列的位置（从1开始计数）；ID 突变的名称；REF 参考序列POS上的碱基；ALT 发生突变的碱基，多个的话以,连接， 可选符号为ATCGN*，大小写敏感；QUAL 基于Phred格式的表示ALT的质量，也可以理解为可靠性；FILTER 过滤后的状态，即按照可靠性进行筛选；INFO 额外信息，可结合注释描述信息进行理解针对vcf格式有如bcftools等软件进行处理。]]></content>
      <categories>
        <category>生物信息分析</category>
      </categories>
      <tags>
        <tag>生物信息分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生物信息分析中的测序概念]]></title>
    <url>%2F%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84%E6%B5%8B%E5%BA%8F%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[De Novo测序：De Novo测序也叫从头测序，是首次对一个物种的基因组进行测序，用生物信息学的分析方法对测序所得序列进行组装，从而获得该物种的基因组序列图谱。全基因组重测序：全基因组重测序是对已知基因组序列的物种进行不同个体的基因组测序，然后运用生物信息学分析手段对序列进行拼接，组装，从而获得该个体的基因组图谱；或者对不同组织（如肿瘤）进行测序，分析体细胞突变。转录组测序(RNA-seq)：转录组是某个物种或者特定细胞类型产生的所有转录本的集合，转录组测序(RNA-seq) 是最近发展起来的利用深度测序技术进行转录分析的方法,可以对全转录组进行系统的研究。宏基因组测序：宏基因组测序，是对特定环境样品中的微生物群体基因组(尤其是那些种类众多的难于培养的微生物)，进行序列测定和功能基因的发掘，来分析微生物群体基因组成及功能，解读微生物群体的多样性与丰度，发掘和研究新的、具有特定功能的基因。目标序列捕获测序：目标序列捕获测序，是将感兴趣的基因组区域定制成特异性探针与基因组DNA进行杂交（固相或液相），将目标基因组区域的DNA片段进行富集后再利用第二代测序技术进行测序。这种新的方法与PCR方法相比，通量高，同时能节省大量的时间及成本。测序深度（Sequencing Depth）：测序得到的碱基总量（bp）与基因组大小（Genome）的比值，它是评价测序量的指标之一。测序深度与基因组覆盖度之间是一个正相关的关系，测序带来的错误率或假阳性结果会随着测序深度的提升而下降。覆盖度（Coverage）：如果一条100bp的序列，我们仅测到80bp，就说这一条序列的覆盖度是80%。]]></content>
      <categories>
        <category>生物信息分析</category>
      </categories>
      <tags>
        <tag>生物信息分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生物信息分析中的reads是什么]]></title>
    <url>%2F%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84reads%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[测序得到的原始图像数据经 base calling 转化为序列数据，我们称之为 raw data 或 raw reads ，结果以 fastq 文件格式存储， fastq 文件为用户得到的最原始文件，里面存储 reads 的序列以及 reads 的测序质量。在 fastq 格式文件中每个 read 由四行描述：1234@read IDTGGCGGAGGGATTTGAACCC+bbbbbbbbabbbbbbbbbbbSingle-end(SE)测序：1个fastq文件Pair-end(PE)测序：2个fastq文件分别存放read1和read2的数据每个序列共有4行，第1行和第3行是序列名称(有的 fq 文件为了节省存储空间会省略第三行“＋”后面的序列名称)；第2行是序列；第4行是序列的测序质量，每个字符对应第2行每个碱基，第4行每个字符对应的 ASCII 值减去64，即为该碱基的测序质量值，比如 h 对应的 ASCII 值为104，那么其对应的碱基质量值是40。碱基质量值范围为0到40。下表为 Solexa 测序错误率与测序质量值简明对应关系，具体计算公式如下：1Q = -10 log10PSolexa测序错误率与测序质量值简明对应关系:]]></content>
      <categories>
        <category>生物信息分析</category>
      </categories>
      <tags>
        <tag>生物信息分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外显子、内含子、mRNA、CDS、ORF的区别与联系]]></title>
    <url>%2F%E5%A4%96%E6%98%BE%E5%AD%90%E3%80%81%E5%86%85%E5%90%AB%E5%AD%90%E3%80%81mRNA%E3%80%81CDS%E3%80%81ORF%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[DNA 复制：概念：DNA 复制：以 DNA 为模板，在 DNA 聚合酶的催化作用下，将四种游离的 dNTP 按照碱基互补配对原则合成新链 DNA 。转录：以 DNA 为模版，在 DNA 指导的 RNA 聚合酶的作用下，将四种游离的 NTP 按照碱基互补配对的原则合成 RNA 。翻译：以 mRNA 为模板，在核糖体内合成蛋白质的过程。特点：DNA 复制：模板为双链 DNA ，合成的新链与模板链一模一样，原料为四种dNTP ，为半保留复制，需要引物。转录：模板为双链 DNA ，为半不连续转录需要引物，原料为四种 NTP ，合成的新链除了把 DNA 上的 T 改为 U 外，其他一样。翻译： 模板为 mRNA ，原料为20中游离的氨基酸，3 个碱基决定一个氨基酸。mRNA：mRNA（messenger RNA，信使RNA）信使 RNA 是由 DNA 经 hnRNA 剪接而成，携带遗传信息的能指导蛋白合成的一类单链核糖核酸。外显子和内含子：基因 DNA 分为编码区和非编码区，编码区包含外显子和内含子，一般非编码区具有基因表达的调控功能，如启动子在非编码区。编码区则转录为 mRNA 并最终翻译成蛋白质。外显子和内含子都被转录到 mRNA 前体 hnRNA 中，当 hnRNA 进行剪接变为成熟的 mRNA 时，内含子被切除，而外显子保留。实际上真正编码蛋白质的是外显子，而内含子则无编码功能。内含子存在于DNA 中，在转录的过程中，DNA 上的内含子也会被转录到前体 RNA 中，但前体 RNA 上的内含子会在 RNA 离开细胞核进行翻译前被切除。CDS：Sequencecodingfor aminoacids in protein 蛋白质编码区 CDS 是Codingsequence的缩写，是编码一段蛋白产物的序列，是结构基因组学术语。开放读码框ORF开放读码框是从一个起始密码子开始到一个终止密码子结束的一段序列；不是所有读码框都能被表达出蛋白产物，或者能表达出占有优势或者能产生生物学功能的蛋白。CDS，是编码一段蛋白产物的序列。CDS 必定是一个 ORF 。但也可能包括很多 ORF 。反之，每个 ORF 不一定都是 CDS 。外显子与 CDS 区不是完全一致的，CDS 区一定属于外显子，但是外显子不一定是 CDS 区，也就是说外显子不一定都能翻译成蛋白的。mRNA 包括 UTR 和 CDS ！]]></content>
      <categories>
        <category>生物信息分析</category>
      </categories>
      <tags>
        <tag>生物信息分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ParallelsDesktop-虚拟机Mac绿色版]]></title>
    <url>%2FParallelsDesktop-%E8%99%9A%E6%8B%9F%E6%9C%BAMac%E7%BB%BF%E8%89%B2%E7%89%88%2F</url>
    <content type="text"><![CDATA[简介：Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。破解教程：压缩包内含教程。下载地址：V140145154版-云盘下载 密码: 9mhddmg打开密码: blog.pangao.vip本软件来源于网络，仅供学习使用，请在24小时内删除，本人不承担任何相关责任！若侵犯某些组织或个人的权益，请联系我删除。]]></content>
      <categories>
        <category>Mac软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Perl处理Excel]]></title>
    <url>%2FPerl%E5%A4%84%E7%90%86Excel%2F</url>
    <content type="text"><![CDATA[优点无需安装模块依赖，功能强大缺点无法实现跨平台，必须依赖win系统和office软件如果想实现跨平台处理excel请移步 perl处理Excel(跨平台)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657use FindBin qw($Bin);use Win32::OLE qw(in with);use Win32::OLE::Const 'Microsoft Excel';my $Excel = Win32::OLE-&gt;GetActiveObject('Excel.Application') || Win32::OLE-&gt;new('Excel.Application', 'Quit');#不显示警告窗口$Excel-&gt;&#123;DisplayAlerts&#125; = 0;my $Book = $Excel-&gt;Workbooks-&gt;Open($file);my $Sheet = $Book-&gt;Worksheets(1); #my $Sheet = $Book-&gt;Worksheets($sheetName); #my $SheetName = $Book-&gt;Worksheets(1)-&gt;&#123;Name&#125;; my $maxRow = $Sheet-&gt;UsedRange-&gt;Rows-&gt;Count;my $maxCol = $Sheet-&gt;UsedRange-&gt;Columns-&gt;Count;foreach my $row(1..$maxRow)&#123; foreach my $col(1..$maxCol)&#123; #隐藏的单元格，过滤 next if $Sheet-&gt;Range("$row:$row")-&gt;EntireRow-&gt;&#123;Hidden&#125;; #获取单元格的值 my $value = $Sheet-&gt;Cells($row,$col)-&gt;&#123;Value&#125;; #修改单元格填充色 $Sheet-&gt;Cells($row,$col)-&gt;Interior-&gt;&#123;Color&#125; = $InColor; #字体加粗 $sheet -&gt; Range("G7:H7") -&gt; Font -&gt; &#123;Bold&#125; = "True"; #字体斜体 $sheet -&gt; Range("G7:H7") -&gt; Font -&gt; &#123;Italic&#125; = "True"; #字体下划线 $sheet -&gt; Range("G7:H7") -&gt; Font -&gt; &#123;Underline&#125; = xlUnderlineStyleSingle; #字体大小 $sheet -&gt; Range("G7:H7") -&gt; Font -&gt; &#123;Size&#125; = 8; #字体名称 $sheet -&gt; Range("G7:H7") -&gt; Font -&gt; &#123;Name&#125; = "Arial"; #字体颜色 $sheet -&gt; Range("G7:H7") -&gt; Font -&gt; &#123;ColorIndex&#125; = 4; #列宽 $sheet -&gt; Range('A:A') -&gt; &#123;ColumnWidth&#125; = 9.14; #行高 $sheet -&gt; Range("8:8") -&gt; &#123;RowHeight&#125; = 30; &#125; &#125;$Book-&gt;Save();$Book-&gt;Close();$Excel-&gt;Quit();]]></content>
      <categories>
        <category>Perl</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Perl处理文件及文件夹]]></title>
    <url>%2FPerl%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627use FindBin qw($Bin);#遍历文件夹my $fileReportDir = $Bin; #出报告所在的文件夹地址if(-e $fileReportDir)&#123;opendir DIR, $fileReportDir || die "Error in opening dir $fileReportDir\n";while( my $file = readdir(DIR))&#123;next if $file eq ".";next if $file eq "..";my $fileAll = $fileReportDir."/".$file;if(!unlink($fileAll))&#123;print "=====程序终止！=====\n删除表格（".$fileAll."）失败，请手动删除\n"; #保留黑框system pause;#程序停止运行die; &#125; &#125; closedir DIR;&#125;#读取文件内容open FILE, "&lt;$file" || die "Not Found file: $file\n";while (&lt;FILE&gt;)&#123;my ($gene,$chr) = (split /\t/,$_)[0,1];&#125;close FILE;]]></content>
      <categories>
        <category>Perl</category>
      </categories>
      <tags>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Perl的简单联网操作]]></title>
    <url>%2FPerl%E7%9A%84%E7%AE%80%E5%8D%95%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[GET123456use LWP::UserAgent;my $browser = LWP::UserAgent-&gt;new(agent =&gt; 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6');my $TARGET_URL = "http://www.omim.org/entry/".$OMIM;my $response = $browser-&gt;get($TARGET_URL);my $htmlcontent = $response-&gt;content;POST123456789101112131415161718192021222324252627use LWP::UserAgent;my $browser = LWP::UserAgent-&gt;new;$browser-&gt;timeout(600); #设置缓冲时间600smy $TARGET_URL = "http://122.114.25.231:8582/emp/selfOpenAccountAction!khQuery.action?step=xhdq";my %headers=('Accept'=&gt;'text/html, application/xhtml+xml, */*','Accept-Encoding'=&gt;'gzip, deflate','Accept-Language' =&gt; 'zh-CN','Cache-Control' =&gt; 'no-cache','Connection' =&gt; 'Keep-Alive','Content-Length' =&gt; '71','Content-Type' =&gt; 'application/x-www-form-urlencoded','Cookie' =&gt; 'JSESSIONID=4D4E92EB8830CA8B5DC7F9AA1751AC71','Host' =&gt; '122.114.25.231:8582','Referer' =&gt; 'http://122.114.25.231:8582/emp/query.jsp','User-Agent' =&gt; 'Mozilla/5.0 (MSIE 9.0; Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko');my $response = $browser-&gt;post($TARGET_URL,[ 'dealer.certificateNum' =&gt; $id,'dealer.name' =&gt; $name,],%headers); if ($response-&gt;is_success) &#123; my $htmlcontentStr = $response-&gt;content;&#125;]]></content>
      <categories>
        <category>Perl</category>
      </categories>
      <tags>
        <tag>Perl</tag>
      </tags>
  </entry>
</search>
